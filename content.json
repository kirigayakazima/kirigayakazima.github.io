{"meta":{"title":"我的博客","subtitle":"","description":"个人博客、kirigayakazima","author":"xuaner","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-11-26T11:21:45.716Z","updated":"2022-11-26T11:21:45.716Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-11-26T14:02:29.242Z","updated":"2022-11-26T14:02:29.242Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欢迎你"},{"title":"所有分类","date":"2022-11-26T11:23:35.091Z","updated":"2022-11-26T11:23:35.091Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-11-26T11:25:18.529Z","updated":"2022-11-26T11:25:18.529Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-11-26T13:14:18.757Z","updated":"2022-11-26T13:14:18.757Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"xuaner"}],"posts":[{"title":"数据结构与算法-03-链表","slug":"数据结构与算法-03-链表","date":"2023-07-17T13:36:16.000Z","updated":"2023-07-17T13:36:46.477Z","comments":true,"path":"2023/07/17/数据结构与算法-03-链表/","link":"","permalink":"http://example.com/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-03-%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表线性表的链式储存结构有很多个结点，每个结点都有一个指针头，左后一个结点的指针为空，通常设置为null或者^表示，第一个结点称作为头结点 头指针 头结点 头指针是指链表指向第一个结点的指针，若链表有头结点，则指向头结点的指针 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可以存放链表的长度) 头指针具有标识作用，所以常用头指针冠以链表的名字 有了头结点，在对第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了 无论链表是否为空，头指针均不为空，头指针是链表的必要元素 头结点不一定是链表必须要素 单链表 空链表​ 链表结构12345typedef struct Node&#123; ElemType data; //数据域 struct Node *Next; //指针域&#125;Node;typedef struct Node *LinkList; (1) 获取当前元素初始条件：顺序线性表​*L*​存在，​*1&lt;=i&lt;=ListLength(L)*​，操作结果：用​*e*​返回​*L*​中第​*i*​个元素的值 123456789101112131415161718Status GetElem(LinkList L, int i, ElemType *e)&#123; int j; LinkList p; p=L-&gt;next; j=1; while(p &amp;&amp; j&lt;i) //若p不是尾节点，则将p的节点变为下一个元素，直到j=i-1，此时指针变为第i元素的地址 &#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i) //若p是尾节点，或者j越界 &#123; return ERROR; &#125; *e = p-&gt;data; //获取第i地址的data数据 return OK;&#125; 从头开始找，直到第个元素为止由于这个算法的时间复杂度取决于1的位置，当i=1​时，则不需要遍历，而i=n​时则遍历n-1​次可以因此最坏情况的时间复杂度为O(n)​。 (2) 链表插入需要先把需要插入的数据的头指向原来的后一位，然后再将原来的前一位指向插入的数据的内容，否则操作相反会导致后一位没有上级 123//正确的插入方式s-&gt;next=p-&gt;next;p-&gt;next=s; 初始条件：顺序线性表​*L*​已存在，​*1&lt;=i&lt;=ListLength(L)*​操作结果：在​*L*​中第​*i*​个位置之前插入新的数据元素​*e*​，​*L*​的长度加​*1* 1234567891011121314151617181920212223Status ListInsert(LinkList *L, int i, ElemType e)&#123; int j; LinkList p, s; p = *L; j=1; while(p &amp;&amp; j&lt;i) //寻找第i个节点 &#123; p = p-&gt;next; ++j; &#125; if(!p || j&gt;i) &#123; return ERROR; &#125; //动态分配一个内存给新创建需要插入的s s = (LinkList)malloc(sizeof(Node)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK;&#125; (3) 链表删除初始条件：顺序线性表​*L*​已存在，​*1&lt;=i&lt;=ListLength(L)*​操作结果：删除在​*L*​中第​*i*​个位置的数据元素，并用​*e*​返回值，​*L*​的长度减​*1*​ 12345678910111213141516171819202122Status ListDelete(LinkList *L, int i, ElemType *e)&#123; int j; LinkList p, q; p = *L; j = 1; while(p-&gt;next &amp;&amp; j&lt;i) &#123; p = p-&gt;next; ++j; &#125; if(!(p-&gt;next) || j&gt;i) &#123; return ERROR; &#125; q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free(q); return OK;&#125; 时间复杂度为O(n)，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显 ‍","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}],"author":"xuaner"},{"title":"OLED-快速上手","slug":"OLED-快速上手","date":"2023-07-14T02:09:10.000Z","updated":"2023-07-14T02:09:40.650Z","comments":true,"path":"2023/07/14/OLED-快速上手/","link":"","permalink":"http://example.com/2023/07/14/OLED-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"OLED常见的OLED​显示屏，0.96寸，128*64 通用流程 开启显示（进入工作模式） 关闭显示（进入睡眠模式） 设置复用率 设置列引脚硬件配置 设置显示时钟分频值&#x2F;振荡频率（刷新率） 设置预充电周期 设置VCOMH反压值 设置电荷泵开启 屏幕控制指令，反色、镜像反转、滚动、淡出、闪烁等动画效果 设置坐标位置1234567891011//指定操作的像素坐标/* X:0-127 y:0-7*/void OLED_Set_Pos(uint8_t x, uint8_t y)&#123; OLED_WriteCommand(0xB0+y); OLED_WriteCommand(((x&amp;0xf0)&gt;&gt;4)|0x10); OLED_WriteCommand((x&amp;0x0f));&#125; 根据不同大小字体显示123456789101112131415161718192021222324252627//在指定位置显示一个字符,包括部分字符//x:0~127//y:0~63//mode:0,反白显示;1,正常显示 //size:选择字体 16/12 void OLED_ShowChar_Pos(uint8_t x,uint8_t y,uint8_t chr,uint8_t SIZE)&#123; unsigned char c=0,i=0; c=chr-&#x27; &#x27;;//得到偏移后的值 if(x&gt;Max_Column-1)&#123;x=0;y=y+2;&#125; if(SIZE ==16) &#123; OLED_Set_Pos(x,y); for(i=0;i&lt;8;i++) OLED_WriteData((uint8_t)F8X16[c*16+i]); OLED_Set_Pos(x,y+1); for(i=0;i&lt;8;i++) OLED_WriteData((uint8_t)F8X16[c*16+i+8]); &#125; else &#123; OLED_Set_Pos(x,y+1); for(i=0;i&lt;6;i++) OLED_WriteData((uint8_t)F6x8[c][i]); &#125;&#125; 直接绘图123456789101112131415/***********功能描述：显示显示BMP图片128×64起始点坐标(x,y),x的范围0～127，y为页的范围0～7*****************/void OLED_DrawBMP(uint8_t x0, uint8_t y0,uint8_t x1, uint8_t y1,uint8_t BMP[])&#123; unsigned int j=0; unsigned char x,y; for(y=y0;y&lt;y1;y++) &#123; OLED_Set_Pos(x0,y); for(x=x0;x&lt;x1;x++) &#123; OLED_WriteData(BMP[j++]); &#125; &#125;&#125; 谷歌恐龙字库​ 123456789101112const uint8_t pic1[] = &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xF8,0xF8,0xFE,0xFF,0xFF,0xFF,0x3F,0x3F,0x0F,0xCF,0xCF, 0x0F,0xCF, 0xCF, 0x0F, 0xCF,0xFF,0xF8,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x00,0x83,0xC7,0xEF,0xDF,0x7F,0xFF,0x71,0xC1,0x88,0x88,0xB8,0xB9,0xB9,0xB8,0x99,0x99,0xC0,0xFF,0xFF,0xC0,0xC0,0xC0,0xC0, 0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x03,0x0F,0x1F,0x1E,0xFE,0xFE,0xEE,0x36,0x9B,0x4F,0xF7,0xE2,0x71,0xBF,0x5D,0xFC,0xFB,0xE2,0x63,0x7F,0x61,0x61,0x61,0x7F,0x61,0xFF,0xFF,0x6F,0x63,0x77,0x73,0x1F,0x1F,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x03,0x03,0xC5,0xEA,0xBD,0xAA,0xBD,0xAE,0xAB,0xBB,0xE7,0xC4,0x07,0x04,0xE7,0xE4,0xBF,0xAB,0xBB,0xAC,0xA8,0xB8,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,&#125;; 动画效果使用绘图加上延时实现 ‍","categories":[{"name":"单片机外设","slug":"单片机外设","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%96%E8%AE%BE/"}],"tags":[{"name":"OLED","slug":"OLED","permalink":"http://example.com/tags/OLED/"}],"author":"xuaner"},{"title":"FreeRTOS-10-CPU利用率","slug":"FreeRTOS-10-CPU利用率","date":"2023-07-13T00:33:47.000Z","updated":"2023-07-13T00:34:45.654Z","comments":true,"path":"2023/07/13/FreeRTOS-10-CPU利用率/","link":"","permalink":"http://example.com/2023/07/13/FreeRTOS-10-CPU%E5%88%A9%E7%94%A8%E7%8E%87/","excerpt":"","text":"CPU利用率CPU​利用率需要控制在一个较好的范围，能够完美响应紧急的事件 开启宏定义portCONFIGURE_TIMER_FOR_RUN_TIME_STATS 1​、portGET_RUN_TIME_COUNTER_VALUE 1​ 创建CPU利用率监控 开启宏定义 12345678910111213//启用运行时间统计功能#define configGENERATE_RUN_TIME_STATS 1//启用可视化跟踪调试#define configUSE_TRACE_FACILITY 1/* 与宏 configUSE_TRACE_FACILITY 同时为 1 时会编译下面 3 个函数* prvWriteNameToBuffer()* vTaskList(),* vTaskGetRunTimeStats()*/#define configUSE_STATS_FORMATTING_FUNCTIONS 1extern volatile uint32_t CPU_RunTime;#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() (CPU_RunTime = 0ul)#define portGET_RUN_TIME_COUNTER_VALUE() CPU_RunTime 创建一个引用，并不是创建一个真实的句柄 1234//CPU利用率static TaskHandle_t LED0_Task_Handle=NULL;static TaskHandle_t LED4_Task_Handle=NULL;static TaskHandle_t CPU_Task_Handle=NULL; 开启定时中断服务 123456789/* 用于统计运行时间 */volatile uint32_t CPU_RunTime = 0UL;void BASIC_TIM_IRQHandler (void)&#123; if ( TIM_GetITStatus( BASIC_TIM, TIM_IT_Update) != RESET ) &#123; CPU_RunTime++; TIM_ClearITPendingBit(BASIC_TIM , TIM_FLAG_Update); &#125;&#125; 创建LED0​任务 12345678910111213static void LED0_Task(void *paramter)&#123; while(1) &#123; LEDA_ON(GPIO_Pin_0); vTaskDelay(500); printf(&quot;led0_task running,LED0_ON\\r\\n&quot;); LEDA_OFF(GPIO_Pin_0); vTaskDelay(500); printf(&quot;led0_task running,LED0_OFF\\r\\n&quot;); &#125;&#125; 创建LED4​任务 12345678910111213static void LED4_Task(void *paramter)&#123; while(1) &#123; LEDA_ON(GPIO_Pin_4); vTaskDelay(300); printf(&quot;led4_task running,LED4_ON\\r\\n&quot;); LEDA_OFF(GPIO_Pin_4); vTaskDelay(300); printf(&quot;led4_task running,LED4_OFF\\r\\n&quot;); &#125;&#125; 创建CPU​任务 12345678910111213141516171819202122static void CPU_Task(void *paramter)&#123; uint8_t CPU_RunInfo[400]; //保存运行时间信息 while (1) &#123; memset(CPU_RunInfo,0,400); //缓冲区清零 vTaskList((char *)&amp;CPU_RunInfo); //获取运行时间信息 printf(&quot;-----------------------\\r\\n&quot;); printf(&quot;任务名 任务状态 优先级 剩余栈 任务序号\\r\\n&quot;); printf(&quot;%s&quot;, CPU_RunInfo); printf(&quot;---------------------------------------------\\r\\n&quot;); memset(CPU_RunInfo,0,400); //信息缓冲区清零 vTaskGetRunTimeStats((char *)&amp;CPU_RunInfo); printf(&quot;任务名 运行计数 使用率\\r\\n&quot;); printf(&quot;%s&quot;, CPU_RunInfo); printf(&quot;---------------------------------------------\\r\\n\\n&quot;); vTaskDelay(1000); &#125;&#125; 需要注意的是定时中断服务要选用TIM1​或者TIM2​ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-09-中断管理","slug":"FreeRTOS-09-中断管理","date":"2023-07-12T14:10:36.000Z","updated":"2023-07-13T00:36:47.280Z","comments":true,"path":"2023/07/12/FreeRTOS-09-中断管理/","link":"","permalink":"http://example.com/2023/07/12/FreeRTOS-09-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/","excerpt":"","text":"中断管理异常：同步异常和异步异常 同步异常：内部事件，处理器指令产生的事件。由内部产生 异步异常：被零除算术运算，读写异常等。由外部硬件装置 中断管理： 支持开关中断 支持恢复中断 支持使能 支持屏蔽 支持可选系统管理的中断优先级 中断种类：外设、中断控制器、CPU本身 中断名词 中断号：特定标志 中断请求：紧急事件需向CPU​提出请求，这一过程称为中断请求 中断优先级：将中断源分为若干个级别，不能级别有不同的优先级 中断处理程序：外设产生中断请求后，CPU​暂停当前任务，响应中断申请执行中断程序 中断触发：中断源给CPU​发信号，将中断触发器置1​ 中断触发类型：外部中断申请通过物理信号发送到NVIC​，可以是电平触发或边沿触发 中断向量：中断服务程序的入口程序 中断向量表：存储中断向量的区域，与中断号对应 临界段：也成为临界区，其中的代码开始执行，则不允许中断打断 硬件实时中不能出现中断嵌套，但是RTOS​等软件实时中可以出现中断嵌套。 中断延迟中断延迟是指中断发生到开始执行中断处理程序第一条指令的时间 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-08-内存管理","slug":"FreeRTOS-08-内存管理","date":"2023-07-12T01:42:21.000Z","updated":"2023-07-12T01:42:51.197Z","comments":true,"path":"2023/07/12/FreeRTOS-08-内存管理/","link":"","permalink":"http://example.com/2023/07/12/FreeRTOS-08-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"内存管理内存通常分为两种：内部存储空间（RAM​）和外部存储空间（硬盘） 避免使用C​语言标准库的malloc​和free​内存函数 嵌入式RAM​可能不足，函数并不总是可用 实现可能很大，占用很大的代码空间 几乎不安全 调用时间不确定，每次可能都不一样 可能产生碎片 会使链接器配置复杂 如果允许堆空间的生长方向覆盖其他变量占据的内存，会成为debug​的灾难 内存管理应用场景 void *pvPortMalloc(size_t xSize)​申请内存 void vPortFree(void *pv)​释放内存 void vPortInitialiseBlocks(void)​初始化内存堆 size_t xPortGetFreeHeapSize(void)​获取当前未分配的内存堆大小 size_t xPortGetMinimumEverFreeHeapSize(void)​获取未分配的内存堆历史最小值 heap_1.c​、heap_2.c​、heap_4.c​内存堆是一个很大的数组 heap_3.c​是使用C​语言原生的malloc​和free​函数，但是进行的安全保护的封装，需要用户通过编译器或者启动文件设置空间 heap_5.c​允许用户使用多个非连续的内存堆空间，同时可以使用外部SDRAM、内存卡等 heap_1 用于从不删除任务、队列、信号量、互斥量等应用程序 函数执行时间是确定并且不会产生内存碎片 不支持释放内存 heap_2 和heap_1​的内存管理算法不同，采用最佳匹配算法，支持释放内存不能将相邻的小碎片内存合并为大内存 可用于反复删除任务、队列、信号量、互斥量等内核对象且不担心内存碎片的应用程序 若存在一些碎片化的任务，那么可能导致内存碎片 具有不确定性，但是比C​语言原生的malloc​高级 不能用于内存分配和释放是随机大小的应用程序 heap_3 简单封装C​语言的malloc​和free​，满足常用的编译器，具有保护功能 需要链接器设置一个堆，malloc​和free​由编译器提供 具有不确定性 很可能增大RTOS​内核代码大小 configTOTAL_HEAP_SIZE​宏定义不起作用 heap_4 在heap_2​的基础上加上了合并算法，能将相邻空闲内存合并为1个更大的块 可用于重复删除任务、队列、信号量、互斥量等的应用程序 可用于分配和释放随机字节内存的应用程序，但并不像heap_2​那样产生严重的内存碎片 具有不确定性，但是效率比C​语言原生的malloc​函数高 heap_5 动态分配和heap_4​是一样，采用最佳匹配和合并算法，并且允许内存跨多个非连续内存区 需要使用vPortDefineHeapRegions()​来实现内存初始化 创建内存管理 内存管理句柄，创建一个引用，并不是创建一个真实的内存管理 1234//内存管理static TaskHandle_t Test_Task_Handle=NULL;uint8_t *Test_Ptr=NULL; Test任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//内存管理static void Test_Task(void *paramter)&#123; uint32_t g_memsize; while (1) &#123; if (Key_BTN(BTN1)==KEY_ON) &#123; if (Test_Ptr==NULL) &#123; //获取当前内存大小 g_memsize=xPortGetFreeHeapSize(); printf(&quot;系统当前内存大小为%d字节，开始申请内存\\r\\n&quot;,g_memsize); Test_Ptr = pvPortMalloc(1024); if (Test_Ptr!=NULL) &#123; printf(&quot;内存申请成功\\r\\n&quot;); printf(&quot;申请到的内存地址为%#x\\r\\n&quot;,(int)Test_Ptr); // 当前剩余内存大小 g_memsize = xPortGetFreeHeapSize(); printf(&quot;系统当前内存剩余大小为%d字节\\r\\n&quot;,g_memsize); sprintf((char*)Test_Ptr,&quot;当前系统TickCount=%d\\r\\n&quot;,xTaskGetTickCount); printf(&quot;写入数据是%s\\r\\n&quot;,(char*)Test_Ptr); &#125;else &#123; printf(&quot;按下Key2释放内存然后申请\\r\\n&quot;); &#125; &#125; &#125; if (Key_BTN(BTN2)==KEY_ON) &#123; if (Test_Ptr!=NULL) &#123; printf(&quot;释放内存\\r\\n&quot;); vPortFree(Test_Ptr); Test_Ptr=NULL; // 获取当前剩余内存 g_memsize = xPortGetFreeHeapSize(); printf(&quot;系统当前内存剩余大小为%d字节\\r\\n&quot;,g_memsize); &#125;else &#123; printf(&quot;按下Key1申请内存再释放\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 按下BTN1​申请内存，并将系统当前TickCount​打印，按下BTN2​释放内存 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-07-任务通知","slug":"FreeRTOS-07-任务通知","date":"2023-07-07T08:17:19.000Z","updated":"2023-07-07T08:17:42.215Z","comments":true,"path":"2023/07/07/FreeRTOS-07-任务通知/","link":"","permalink":"http://example.com/2023/07/07/FreeRTOS-07-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5/","excerpt":"","text":"任务通知任务通知是一种任务间通信的手段，比使用信号量更节省资源，解除阻塞时间更快 无需创建队列 更节省RAM空间 发送通知任务几种模式：通知未读，不覆盖通知值；直接覆盖通知值；设置通知位的一个或多位，当作事件组；递增通知值，当做计数信号量。 由于必须指定接收通知的任务，只能有一个任务接收通知。 只有等待通知的任务可以被阻塞，发送通知的任务不会因为发送失败进入阻塞态。 任务通知运行机制12//开启任务通知功能，默认开启#define configUSE_TASK_NOTIFICATIONS 1 随任务创建而初始化 任务通知和队列消息的运行机制一致 任务通知常见函数 xTaskGenericNotify()​​发送任务通知，是任务通知的原型 xTaskNotifyGive()​​调用任务通知，并将任务通知值加1，可以作为二值信号量和计数信号量的低配版，更加轻量化，原型xTaskNotify()​​ xTaskNotifyGiveFromISR()​​中断调用任务通知 xTaskNotify()​​用于任务直接向另一个任务发送一个事件 xTaskNotifyFromISR()​​ 中断中使用，原型为xTaskGenericNotifyFromISR()​​ xTaskGenericNotifyFromISR()​​通用中断发送任务通知 xTaskNotifyAndQuery()​​和xTaskNotify()​​功能类似，附加了回传接收任务的通知值，若不需要回传则等同于xTaskNotify()​​ xTaskNotifyAndQueryFromISR()​​中断用 ulTaskNotifyTake()​可作为轻量级获取二值信号量和计数信号量的实现，用于自身句柄的调用 xTaskNotifyWait()​可以用于实现全功能的等待任务通知，更轻量化 代替消息队列设计3个任务，2个任务接收消息通知来控制LED​，1个任务通过2个按钮来发送消息通知 接收、发送通知句柄，创建一个引用，并不是创建一个真实的消息通知 123456//任务通知句柄static TaskHandle_t Receive1_Task_Handle = NULL;static TaskHandle_t Receive2_Task_Handle = NULL;static TaskHandle_t Send_Task_Handle = NULL;#define USE_CHAR 0 //测试字符串配置1，测试变量配置0 创建一个真实的句柄 1234567891011121314151617181920//Receive1_Task任务xReturn =xTaskCreate(Receive1_Task,&quot;Receive1_Task&quot;,512,NULL,2,(TaskHandle_t *)&amp;Receive1_Task_Handle);if (xReturn==pdPASS)&#123; printf(&quot;创建Receive1_Task任务成功\\r\\n&quot;);&#125;//Receive2_Task任务xReturn = xTaskCreate(Receive2_Task,&quot;Receive2_Task&quot;,512,NULL,3,(TaskHandle_t *)&amp;Receive2_Task_Handle);if (xReturn==pdPASS)&#123; printf(&quot;创建Receive2_Task任务成功\\r\\n&quot;);&#125;//Receive2_Task任务xReturn = xTaskCreate(Send_Task,&quot;Send_Task&quot;,512,NULL,4,(TaskHandle_t *)&amp;Send_Task_Handle);if (xReturn==pdPASS)&#123; printf(&quot;创建Send_Task任务成功\\r\\n&quot;);&#125; 接收通知任务1 12345678910111213141516171819202122232425262728static void Receive1_Task(void *paramter)&#123; BaseType_t xReturn = pdTRUE;#if USE_CHAR char *r_char;#else uint32_t r_num;#endif while (1) &#123; //获取任务通知，没获取到则等待 xReturn = xTaskNotifyWait(0x0, //进入函数的时候不清除任务Bit ULONG_MAX, //退出函数的时候清除所以的Bit#if USE_CHAR (uint32_t *)&amp;r_char, //保存任务通知值#else &amp;r_num, //保存任务通知值#endif portMAX_DELAY); //阻塞时间 if(xReturn==pdTRUE)#if USE_CHAR printf(&quot;Receive1_Task 任务通知%s \\r\\n&quot;,r_char);#else printf(&quot;Receive1_Task 任务通知%d \\r\\n&quot;,r_num);#endif LED0_Turn(); &#125;&#125; 接收通知任务2 12345678910111213141516171819202122232425262728293031static void Receive2_Task(void *paramter)&#123; BaseType_t xReturn = pdTRUE;#if USE_CHAR char *r_char;#else uint32_t r_num;#endif while (1) &#123; //获取任务通知，没获取到则一直等待 xReturn = xTaskNotifyWait(0x0, ULONG_MAX,#if USE_CHAR (uint32_t *)&amp;r_char,#else &amp;r_num,#endif portMAX_DELAY); if(xReturn == pdTRUE) &#123;#if USE_CHAR printf(&quot;Receive2_Task 任务通知%s \\r\\n&quot;,r_char);#else printf(&quot;Receive2_Task 任务通知%d \\r\\n&quot;,r_num);#endif LED7_Turn(); &#125; &#125;&#125; 发送通知任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void Send_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE;#if USE_CHAR char test_str1[]=&quot;this is mail test 1&quot;; //消息1 char test_str1[]=&quot;this is mail test 2&quot;; //消息2#else uint32_t send1=1; uint32_t send2=2;#endif while (1) &#123; //KEY1按下 if (Key_BTN(BTN1)==KEY_ON) &#123; xReturn = xTaskNotify(Receive1_Task_Handle, //任务句柄#if USE_CHAR (uint32_t)&amp;test_str1, //发送数据，最大4字节#else send1, //发送数据，最大4字节#endif eSetValueWithOverwrite); //覆盖当前通知 if(xReturn==pdTRUE) &#123; printf(&quot;Receive1_Task_Handle 任务通知释放成功\\r\\n&quot;); &#125; &#125; //KEY2按下 if (Key_BTN(BTN2)==KEY_ON) &#123; xReturn = xTaskNotify(Receive2_Task_Handle,#if USE_CHAR (uint32_t)&amp;test_str2,#else send2,#endif eSetValueWithOverwrite); if (xReturn==pdTRUE) &#123; printf(&quot;Receive2_Task_Handle 任务通知释放成功\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 按下BTN1​后，通信接收任务1，LED0​亮，按下BTN2​后，通信接收任务2，LED7​亮 代替二值信号量设计3个任务，2个任务接收消息通知来控制LED​，1个任务通过2个按钮来发送消息通知，按钮控制释放信号量句柄，注意ulTaskNotifyTake​的使用，在自身句柄对应的Task​中调用 前置和代替消息队列相同​ 接收通知任务1 12345678910static void Receive1_Task(void *paramter)&#123; while (1) &#123; //获取任务通知，没有则一直等待 ulTaskNotifyTake(pdTRUE,portMAX_DELAY); printf(&quot;Receive1_Task 任务通知获取成功\\r\\n&quot;); LED0_Turn(); &#125;&#125; 接收通知任务2 123456789static void Receive2_Task(void *paramter)&#123; while (1) &#123; ulTaskNotifyTake(pdTRUE,portMAX_DELAY); printf(&quot;Receive2_Task 任务通知获取成功\\r\\n&quot;); LED7_Turn(); &#125;&#125; 发送通知任务 123456789101112131415161718192021222324252627static void Send_Task(void *paramter)&#123; BaseType_t xReturn=pdPASS; while (1) &#123; if (Key_BTN(BTN1)==KEY_ON) &#123; xReturn = xTaskNotifyGive(Receive1_Task_Handle); if (xReturn==pdTRUE) &#123; printf(&quot;Receive1_Task 任务释放成功\\r\\n&quot;); &#125; &#125; if (Key_BTN(BTN2)==KEY_ON) &#123; xReturn = xTaskNotifyGive(Receive2_Task_Handle); if (xReturn == pdTRUE) &#123; printf(&quot;Receive2_Task 任务释放成功\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 按下BTN1​后，通信接收任务1，LED0​亮，按下BTN2​后，通信接收任务2，LED7​亮 代替计数信号量创建2个任务，1个用于等待通知，申请车位。另一个用于释放信号量，释放车位。 接收、发送通知句柄，创建一个引用，并不是创建一个真实的消息通知 123//任务通知-计数信号量替代static TaskHandle_t Take_Task_Handle=NULL;static TaskHandle_t Give_Task_Handle=NULL; 申请车位 12345678910111213141516171819static void Take_Task(void *paramter)&#123; uint32_t take_num=pdPASS; while (1) &#123; if(Key_BTN(BTN1)==KEY_ON) &#123; //没获取到，就一直等待 take_num=ulTaskNotifyTake(pdFALSE,0); if (take_num&gt;0) &#123; printf(&quot;成功申请到车位，当前车位%d\\r\\n&quot;,take_num-1); &#125;else &#123; printf(&quot;KEY1按下，无多余车位。请按下KEY2释放车位\\r\\n&quot;); &#125; &#125; &#125;&#125; 释放车位 123456789101112131415161718static void Give_Task(void *paramter)&#123; BaseType_t xReturn = pdPASS; while (1) &#123; if (Key_BTN(BTN2)==KEY_ON) &#123; xReturn = xTaskNotifyGive(Take_Task_Handle); if (xReturn==pdPASS) &#123; printf(&quot;KEY2按下，释放一个车位\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 按下KEY1​，无车位；按下KEY2​2次释放2个车位，再按下KEY1​申请2个车位 代替事件组创建2个任务，一个任务用于监听事件，一个任务用于控制BTN1​和BTN2​来触发事件 事件组句柄，创建一个引用，并不是创建一个真实的事件组 12345678//事件组代替static TaskHandle_t LED7_Task_Handle=NULL;static TaskHandle_t KEY_Task_Handle=NULL;//事件句柄static EventGroupHandle_t Event_Handle=NULL;#define KEY1_EVENT (0x01 &lt;&lt; 0) //设置掩码的位0 创建一个真实的事件组 12345Event_Handle = xEventGroupCreate();if (Event_Handle!=NULL)&#123; printf(&quot;事件组句柄创建成功\\r\\n&quot;);&#125; LED灯任务 123456789101112131415161718192021222324252627static void LED7_Task(void *paramter)&#123; uint32_t r_event=0; uint32_t last_event=0; BaseType_t xReturn=pdPASS; while(1) &#123; xReturn = xTaskNotifyWait(0x0, //进去函数不清除任务Bit ULONG_MAX, //退出函数清除所有bit &amp;r_event, //保存任务通知值 portMAX_DELAY); //阻塞时间 if (xReturn == pdPASS) &#123; last_event |= r_event; if (last_event == (KEY1_EVENT|KEY2_EVENT)) &#123; last_event=0; printf(&quot;KEY1和KEY2都按下\\r\\n&quot;); LED7_Turn(); &#125;else &#123; last_event=r_event; &#125; &#125; &#125;&#125; KEY任务 123456789101112131415161718192021static void KEY_Task(void *paramter)&#123; while(1) &#123; if( Key_BTN(BTN1) == 0 ) &#123;/* K1 被按下 */ printf(&quot;K1 被按下\\r\\n&quot;); xTaskNotify(LED7_Task_Handle, //任务句柄 KEY1_EVENT, //需要触发的事件 eSetBits); //设置通知的值 &#125; if( Key_BTN(BTN2) == 0 ) &#123;/* K2 被按下 */ printf(&quot;K2 被按下\\r\\n&quot;); xTaskNotify(LED7_Task_Handle, KEY2_EVENT, eSetBits); &#125; vTaskDelay(20); &#125;&#125; 按下BTN1​，设置事件1，按下BTN2​，设置事件2，触发LED​事件 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-06-软件定时器","slug":"FreeRTOS-06-软件定时器","date":"2023-07-05T08:03:07.000Z","updated":"2023-07-05T08:03:44.357Z","comments":true,"path":"2023/07/05/FreeRTOS-06-软件定时器/","link":"","permalink":"http://example.com/2023/07/05/FreeRTOS-06-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"","text":"软件定时器软件定时器是一种基于硬件定时器的资源利用手段，相当于扩展了定时器数量。 允许开启关闭软件定时 创建软件定时 启动软件定时 停止软件定时 复位软件定时 删除软件定时 软件定时运行机制123//开启宏定义#define configUSE_TIMERS 1#define configTIMER_QUEUE_LENGTH 10 单次模式，定时完毕只执行一次回调 周期模式，定时完毕周期性执行回调 ‍ 软件定时精度不如硬件定时，且容易被打断，用于一些辅助性任务 软件定时通信采用队列消息 软件回调应该快进快出，不能有阻塞行为，不允许死循环 定时器常见函数 xTimerCreate()​创建一个定时器，返回句柄 xTimerStart()​启动定时器 xTimerStartFromISR()​中断启动定时器 xTimerStop()​停止定时器 xTimerStopFromISR()​中断停止定时器 xTimerDelete()​删除定时器 创建定时器创建2个定时器回调任务，其中一个周期1s定时任务，另一个5s单次任务 开启宏定义 1234567//中断事件组#define configUSE_TIMERS 1#define INCLUDE_xTimerPendFunctionCall 0//软件定时器队列长度#define configTIMER_QUEUE_LENGTH 10 //软件定时器优先级#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES-1) 定时器句柄，创建一个引用，并不是创建一个真实的定时器 123456//软件定时器句柄static TimerHandle_t Swtmr1_Handle=NULL;static TimerHandle_t Swtmr2_Handle=NULL;static uint32_t TmrCb_Count1=0; //记录定时器1回调函数执行次数static uint32_t TmrCb_Count2=0; //记录定时器2回调函数执行次数 创建真实的定时器1 1234567//定时器句柄 Swtmr1_Handle = xTimerCreate( (const char*)&quot;AutoReloadTimer&quot;, //定时器名称 1000, //定时器周期 pdTRUE, //周期模式 (void *)1, //为每个计时器分配索引唯一ID Swtmr1_Callback); //回调函数 创建真实的定时器2 1234567//定时器句柄 Swtmr2_Handle = xTimerCreate( (const char*)&quot;OneShotTimer&quot;, //定时器名称 5000, //定时器周期 pdFALSE, //周期模式 (void *)2, //为每个计时器分配索引唯一ID Swtmr2_Callback); //回调函数 定时器1回调函数 123456789101112static void Swtmr1_Callback(void *paramter)&#123; TickType_t tick_num1; TmrCb_Count1++; //每次回调自加1 tick_num1=xTaskGetTickCount(); //获取滴答计时器计数值 LED0_Turn(); printf(&quot;swtmr1_callback回调函数执行次数%d\\r\\n&quot;,TmrCb_Count1); printf(&quot;滴答计时器计数值%d\\r\\n&quot;,tick_num1);&#125; 定时器2回调函数 123456789101112static void Swtmr2_Callback(void *paramter)&#123; TickType_t tick_num2; TmrCb_Count2++; //每次回调自加1 tick_num2=xTaskGetTickCount(); //获取滴答计时器计数值 // LED0_Turn(); printf(&quot;swtmr2_callback回调函数执行次数%d\\r\\n&quot;,TmrCb_Count2); printf(&quot;滴答计时器计数值%d\\r\\n&quot;,tick_num2);&#125; 每过1s，定时器1运行一次，第5s，定时器2运行一次 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-05-事件","slug":"FreeRTOS-05-事件","date":"2023-07-04T13:53:11.000Z","updated":"2023-07-04T13:53:32.949Z","comments":true,"path":"2023/07/04/FreeRTOS-05-事件/","link":"","permalink":"http://example.com/2023/07/04/FreeRTOS-05-%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"事件事件是一种任务间通信的技术，和信号量不同，可以实现一对多，多对多的通信，但是不涉及数据的传输。 configUSE_16_BIT_TICKS​ 开启后，uxEventBits​为16位，8位存储事件组；未开启时，uxEventBits​为32位，24位存储事件组。 事件只与任务相关联，事件之间彼此独立。 事件只同于同步，不涉及数据传输。 事件无队列消息性质，多次向同一任务发送事件，若未被读取，则视为一次事件。 支持事件等待超时机制。 事件运行机制12345//中断事件组#define configUSE_TIMERS 0#define INCLUDE_xTimerPendFunctionCall 0//软件定时器优先级#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES-1) 事件接收成功后，需要使用xClearOnExit()​来清除事件类型，否则不会清除已接收的事件，需要手动显示清除。 24位存储事件中，1​表示事件已发生，0​表示事件未发生 任务唤醒遵循事件的或与逻辑 事件常见函数 xEventGroupCreate()​创建事件组，返回一个句柄 xEventGroupDelete()​删除事件 xEventGroupSetBits()​置位事件组中指定的位，置位后，阻塞该位的任务会被解锁。 xEventGroupSetBitsFromISR()​中断置位事件组，需要开启configUSE_TIMERS 1​和INCLUDE_xTimerPendFunctionCall 1​宏定义 xEventGroupWaitBits()​等待事件，获取事件标志位。 xEventGroupClearBits()​清除事件组置位 xEventGroupClearBitsFromISR()​中断清除事件组置位 创建事件创建2个Btn​任务控制LED​任务，当只按下BTN1​时，不亮，接着按下BTN2​后，亮。此时相当于标志位变得和设定相同。 开启宏定义 12345//中断事件组#define configUSE_TIMERS 0#define INCLUDE_xTimerPendFunctionCall 0//软件定时器优先级#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES-1) 事件句柄，创建一个引用，并不是创建一个真实的事件 12345//事件句柄static EventGroupHandle_t Event_Handle=NULL;#define KEY1_EVENT (0x01 &lt;&lt; 0) //设置掩码的位0#define KEY2_EVENT (0x01 &lt;&lt; 1) //设置掩码的位1 创建一个真实的事件 12//创建事件句柄Event_Handle = xEventGroupCreate(); LED任务 12345678910111213141516171819202122static void LED0_Event_Task(void *paramter)&#123; EventBits_t r_event; while (1) &#123; r_event = xEventGroupWaitBits( Event_Handle, //事件句柄 KEY1_EVENT | KEY2_EVENT, //接收感兴趣事件 pdTRUE, //退出时清除事件位 pdTRUE, //满足感兴趣的所有事件 portMAX_DELAY); //超时一直等待 if (r_event &amp; (KEY1_EVENT | KEY2_EVENT) == (KEY1_EVENT | KEY2_EVENT)) &#123; printf(&quot;KEY1和KEY2都按下\\r\\n&quot;); LED0_Turn(); &#125;else &#123; printf(&quot;事件错误\\r\\n&quot;); &#125; &#125;&#125; Key任务 123456789101112131415161718static void KEY_Event_Task(void *paramter)&#123; while (1) &#123; if(Key_BTN(BTN1)==KEY_ON) &#123; printf(&quot;KEY1按下\\r\\n&quot;); xEventGroupSetBits(Event_Handle,KEY1_EVENT); &#125; if (Key_BTN(BTN2)==KEY_ON) &#123; printf(&quot;KEY2按下\\r\\n&quot;); xEventGroupSetBits(Event_Handle,KEY2_EVENT); &#125; vTaskDelay(20); &#125;&#125; 当BTN1和BTN2都按下后，才会翻转信号 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-04-信号量","slug":"FreeRTOS-04-信号量","date":"2023-07-02T13:49:30.000Z","updated":"2023-07-03T13:19:02.534Z","comments":true,"path":"2023/07/02/FreeRTOS-04-信号量/","link":"","permalink":"http://example.com/2023/07/02/FreeRTOS-04-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"信号量信号量类似于裸机开发中的标志位，用于任务间通信的变量，或者成为标志位。 临界资源：任何时刻只能被一个任务访问的资源 递归信号量和互斥量都实现继承优先级机制，降低优先级反转的危害 二值信号量运行机制 类似于互斥量，但是没有互斥量的优先级继承机制 偏向于同步功能，任务与任务的同步，任务与中断的同步 等效于一个只有一个消息的队列，只存在两种状态：有消息或者无消息 信号被获取时为0，被释放时为1 二值信号量无效时，有其他任务获取信号量，则任务进入阻塞态 某时刻信号量被中断或任务释放时，其他进入阻塞态的最高优先级任务进入就绪态 ‍ 计数信号量运行机制123//使用计数信号量需要开启宏定义//开启计数信号量#define configUSE_COUNTING_SEMAPHORES 1 当事件发生时，信号量被释放，计数值加一 当事件被处理时，信号量被取走，计数值减一 信号计数值表示还未处理事件数量 使用完资源必须返还信号量，信号量为0时表示无资源可用 可用于资源管理，允许多个任务获取信号量进行资源访问，当访问个数到达最大时，其他任务进入阻塞态，直到有任务释放资源，类似于二值信号量访问资源的过程 互斥信号量运行机制12345//使用互斥信号量需要开启宏定义//开启互斥量#define configUSE_MUTEXES 1//开启递归互斥量#define configUSE_RECURSIVE_MUTEXES 1 特殊的二值信号量，拥有优先级继承机制 信号量创建之初为满，使用临界资源时，先获取信号量使其为空，防止其他任务使用临界资源。 低优先级任务申请互斥量，高优先级任务申请不到进入阻塞态，低优先级任务临时继承高优先级的优先级。 适用于可能引发优先级翻转的场景 可递归使用，形成递归互斥量，任务可能会多次获取互斥量的情况下。这样可以避免同一任务多次递归持有而造成死锁的问题。 互斥量不能在中断使用，优先级继承只在普通任务中有效，同一时期只能有一个任务获取互斥量进行资源访问 递归信号量运行机制 获取递归信号量的任务可以重复获取该量，拥有该量的所有权 递归几次就要返还几次，有点类似任务的挂起和恢复之间的关系 ‍ 信号常见函数 xSemaphoreCreateBinary()​​创建二值信号量，返回一个句柄，函数原型xQueueGenericCreate()​​ xSemaphoreCreateCounting()​​创建计数信号量，返回一个句柄，原型​xQueueGenericCreate()​​ xSemaphoreGive()​​释放信号量，可用于二值信号量、互斥信号量、计数信号量的任务释放，不能用于递归信号量，原型xQueueGenericSend()​​ xSemaphoreGiveFromISR()​​用于中断的释放信号量，只能用于二值信号量、计数信号量，原型xQueueGiveFromISR()​​ xSemaphoreTake()​获取信号量，可用于二值信号量、互斥信号量、计数信号量的任务获取，不能用于递归信号量，原型xQueueGenericReceive()​，该操作类似任务访问队列消息的过程。 xSemaphoreTakeFromISR()​​，用于中断的获取信号量，只能用于二值信号量、计数信号量 xSemaphoreCreateMutex()​创建互斥量，返回一个句柄，只能被同一个任务获取，再次获取会失败。原型xQueueCreateMutex()​，原型的原型为xQueueGenericCreate()​ prvInitialiseMutex()​初始化互斥量 xSemaphoreCreateRecursiveMutex()​创建递归互斥量，可以被同一个任务获取很多次，获取前先释放。原型xQueueCreateMutex()​ xSemaphoreDelete()​信号量删除 xSemaphoreTakeRecursive()​获取递归互斥量，原型xQueueTakeMutexRecursive()​，该函数不能获取由xSemaphoreCreateMutex()​创建的互斥量 xSemaphoreGiveRecursive()​释放递归互斥量，原型xQueueGiveMutexRecursive()​ 创建二值信号量设计1个Button​任务，通过按键发送控制LED0​的开关，二值量操作信息通过串口显示 二值量句柄，创建一个引用，并不是创建一个真实的二值量 12345//创建一个二值信号量句柄SemaphoreHandle_t Binary_Handle=NULL;//发送和接收任务-信号量static void Receive_Semaph_Task(void *paramter);static void Send_Semaph_Task(void *paramter); 创建一个真实的二值量 12//创建一个二值信号量Binary_Handle = xSemaphoreCreateBinary(); 接收数据任务控制LED0 123456789101112131415static void Receive_Semaph_Task(void *paramter)&#123; BaseType_t xReturn=pdPASS; uint32_t r_queue; while (1) &#123; //获取二值信号量 xReturn = xSemaphoreTake(Binary_Handle,portMAX_DELAY); if(xReturn==pdPASS) &#123; printf(&quot;二值信号量获取成功\\r\\n&quot;); &#125; LED0_Turn(); &#125;&#125; Button控制发送数据任务 123456789101112131415161718192021222324252627282930313233343536static void Send_Semaph_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE; while (1) &#123; if (Key_BTN(BTN1)==KEY_ON) &#123; //先释放一下二值信号量 xReturn = xSemaphoreGive(Binary_Handle); if (xReturn==pdTRUE) &#123; printf(&quot;二值信号量释放成功\\r\\n&quot;); &#125;else &#123; printf(&quot;二值信号量释放失败\\r\\n&quot;); &#125; &#125; if (Key_BTN(BTN2)==KEY_ON) &#123; //先释放一下二值信号量 xReturn = xSemaphoreGive(Binary_Handle); if (xReturn==pdTRUE) &#123; printf(&quot;二值信号量释放成功\\r\\n&quot;); &#125;else &#123; printf(&quot;二值信号量释放失败\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 创建计数二值量设计2个Button​任务，通过按键BTN1​申请车位，按键BTN2​释放车位，最大车位5 开启宏定义 12//开启计数信号量#define configUSE_COUNTING_SEMAPHORES 1 计数信号量句柄，创建一个引用，并不是创建一个真实的计数信号量 12345678//创建一个计数信号量句柄SemaphoreHandle_t CountSem_Handle=NULL;//计数信号量-申请释放车位static void Take_Task(void *paramter);static void Give_Task(void *paramter);//计数信号量-申请释放车位任务句柄static TaskHandle_t Take_Task_Handle=NULL;static TaskHandle_t Give_Task_Handle=NULL; 创建一个真实的计数信号量 123//创建一个计数信号量CountSem_Handle =xSemaphoreCreateCounting(5, //最大车位5 5); //当前空闲车位5 BTN1控制申请车位 1234567891011121314151617181920212223static void Take_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE; while (1) &#123; if (Key_BTN(BTN1)==KEY_ON) &#123; //获取计数信号量 xReturn = xSemaphoreTake(CountSem_Handle, 0); //等待时间：0 if (xReturn==pdTRUE) &#123; printf(&quot;BTN1按下，申请车位成功\\r\\n&quot;); &#125;else &#123; printf(&quot;BTN1按下，车位已满，申请车位失败\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; BTN2释放车位 123456789101112131415161718192021static void Give_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE; while (1) &#123; if (Key_BTN(BTN2)==KEY_ON) &#123; //获取计数信号量 xReturn = xSemaphoreGive(CountSem_Handle); if (xReturn==pdTRUE) &#123; printf(&quot;BTN2按下，释放一个车位\\r\\n&quot;); &#125;else &#123; printf(&quot;BTN2按下，无车位可被释放\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; 创建二值信号量优先级翻转创建Low​、Mid​、High​三个任务，其中Low​获取信号后，被Mid​打断，但是Mid​未执行完，执行完后，Low​释放信号后，High​才能获取信号，在此之前High​进入阻塞态。 二值信号量句柄，创建一个引用，并不是创建一个真实的二值信号量 1234567//优先级翻转static TaskHandle_t LowPriority_Task_Handle=NULL;static TaskHandle_t MidPriority_Task_Handle=NULL;static TaskHandle_t HighPriority_Task_Handle=NULL;//创建一个二值信号量句柄SemaphoreHandle_t Binary_Handle=NULL; 创建一个真实的二值量 12//创建一个二值信号量Binary_Handle = xSemaphoreCreateBinary(); Low任务 12345678910111213141516171819202122232425static void LowPriority_Task(void *paramter)&#123; static uint32_t i; BaseType_t xReturn=pdPASS; while (1) &#123; printf(&quot;Low任务获取二值信号量\\r\\n&quot;); xReturn = xSemaphoreTake(Binary_Handle,portMAX_DELAY); if(xReturn==pdPASS) &#123; printf(&quot;Low任务获取成功\\r\\n&quot;); &#125; for ( i = 0; i &lt; 2000000; i++) //模拟占用 &#123; taskYIELD(); //发起任务调度 &#125; printf(&quot;Low任务释放二值信号量\\r\\n&quot;); xReturn = xSemaphoreGive(Binary_Handle); LED0_Turn(); vTaskDelay(500); &#125;&#125; Mid任务 12345678static void MidPriority_Task(void *paramter)&#123; while (1) &#123; printf(&quot;Mid任务运行中\\r\\n&quot;); vTaskDelay(500); &#125;&#125; High任务 123456789101112131415161718static void HighPriority_Task(void *paramter)&#123; BaseType_t xReturn = pdTRUE; while (1) &#123; printf(&quot;High任务获取二值信号量\\r\\n&quot;); xReturn = xSemaphoreTake(Binary_Handle,portMAX_DELAY); if (xReturn==pdTRUE) &#123; printf(&quot;High任务获取成功\\r\\n&quot;); &#125; LED0_Turn(); xReturn = xSemaphoreGive(Binary_Handle); vTaskDelay(500); &#125;&#125; 注意调整AppTaskCreate​中的优先级顺序 创建互斥量 开启宏定义 1234//开启互斥量#define configUSE_MUTEXES 1//开启递归互斥量#define configUSE_RECURSIVE_MUTEXES 1 互斥句柄，创建一个引用，并不是创建一个真实的互斥 1234567//优先级翻转static TaskHandle_t LowPriority_Task_Handle=NULL;static TaskHandle_t MidPriority_Task_Handle=NULL;static TaskHandle_t HighPriority_Task_Handle=NULL;//创建互斥量句柄SemaphoreHandle_t MutexSem_Handle=NULL; 创建一个真实的互斥量 12//创建互斥量MutexSem_Handle = xSemaphoreCreateMutex(); Low任务 12345678910111213141516171819202122232425static void LowPriority_Task(void *paramter)&#123; static uint32_t i; BaseType_t xReturn=pdPASS; while (1) &#123; printf(&quot;Low任务获取互斥量\\r\\n&quot;); xReturn = xSemaphoreTake(MutexSem_Handle,portMAX_DELAY); if(xReturn==pdPASS) &#123; printf(&quot;Low任务获取成功\\r\\n&quot;); &#125; for ( i = 0; i &lt; 2000000; i++) //模拟占用 &#123; taskYIELD(); //发起任务调度 &#125; printf(&quot;Low任务释放互斥量\\r\\n&quot;); xReturn = xSemaphoreGive(MutexSem_Handle); LED0_Turn(); vTaskDelay(1000); &#125;&#125; Mid任务 12345678static void MidPriority_Task(void *paramter)&#123; while (1) &#123; printf(&quot;Mid任务运行中\\r\\n&quot;); vTaskDelay(500); &#125;&#125; High任务 12345678910111213141516171819static void HighPriority_Task(void *paramter)&#123; BaseType_t xReturn = pdTRUE; while (1) &#123; printf(&quot;High任务获取互斥量\\r\\n&quot;); xReturn = xSemaphoreTake(MutexSem_Handle,portMAX_DELAY); if (xReturn==pdTRUE) &#123; printf(&quot;High任务获取成功\\r\\n&quot;); &#125; LED0_Turn(); printf(&quot;High释放互斥量\\r\\n&quot;); xReturn = xSemaphoreGive(MutexSem_Handle); vTaskDelay(1000); &#125;&#125; 注意调整AppTaskCreate​中的优先级顺序 在低优先级任务运行的时候，中优先级任务无法抢占低优先级的任务，低优先级任务的优先级发生翻转。","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-03-消息队列","slug":"FreeRTOS-03-消息队列","date":"2023-07-01T02:32:35.000Z","updated":"2023-07-01T02:32:56.899Z","comments":true,"path":"2023/07/01/FreeRTOS-03-消息队列/","link":"","permalink":"http://example.com/2023/07/01/FreeRTOS-03-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"消息队列消息队列是一种用于线程间通信的技术，在FreeRTOS​中则用于任务间通信，其中的任务可以视为线程。 支持先进先出、后进先出 消息队列运行机制 创建消息队列单独划分一个内存空间，内存大小&#x3D;控制块大小+单个消息空间*队列长度，然后初始化消息队列，空间大小无法更改。 初始化后，内存空间中会包含头指针等信息，消耗部分内存，删除消息队列后空间释放。 每个空间存放不大于uxItemSize​ 的任意类型数据。 队列未满，消息会被拷贝到队列末尾。紧急消息则发送至队列首。 当有任务请求队列消息时，任务变为阻塞态在等待时间内等待消息，若消息空间内无消息直至超时，则任务变为就绪态，否则接收消息变为就绪态。 消息队列不再使用后，应该及时删除，释放资源。 任务等待消息的几种状态 即刻型：任务等待消息，若队列中没有消息，任务直接变为就绪态，不再等待消息。 等待型：任务变为阻塞态，在等待时间内等待队列消息，若有消息则接收并变为就绪态，若无就超时变为就绪态。 无限型：任务一直等待消息，直到消息出现。 注意事项：只有任务才能进入阻塞态，中断不能进入阻塞态，中断有单独的消息函数 ​ 队列常见函数 xQueueCreate()​创建一个队列返回一个指针类型的句柄 使用的是动态内存，需要开启configSUPPORT_DYNAMIC_ALLOCATION 1​宏定义 创建的时候，申请内存是连续的，保证队列控制块和消息空间的连续 xQueueStaticCreate()​使用静态内存创建一个队列 vQueueDelete()​队列删除 xQueueSend()​向队列发送消息，以拷贝的形式在队列尾部加入一个消息，不能在中断中使用 xQueueSendToBack()​和xQueueSend()​等效 xQueueSendFromISR()​用于中断中向队列尾部发送一个消息 xQueueSendToBackFromISR()​和xQueueSendFromISR()​等效 xQueueGenericSend()​通用消息队列发送，是上述发送的原型 xQueueGenericSendFromISR()​中断通用消息队列发送，中断发送的原型 xQueueReceive()​从队列中接收消息，并将消息删除，将消息拷贝至缓冲区 xQueuePeek()​从队列中接收消息，不删除消息 xQueueReceiveFromISR()​中断中使用 xQueuePeekFromISR()​中断中使用 xQueueGenericReceive()​通用接收消息，上述的原型 创建队列设计2个Button​任务，通过按键发送不同的Data​数据，然后将发送的Data​数据在另一个任务中接收，最终在串口显示 队列消息句柄，创建一个引用，并不是创建一个真实的队列消息，同时设置队列的属性 1234//创建一个Queue句柄QueueHandle_t Test_Queue=NULL;#define QUEUE_LEN 4 //队列长度#define QUEUE_SIZE 4 //单个消息空间大小 创建一个真实的队列 12//创建一个Queue队列Test_Queue=xQueueCreate((UBaseType_t)QUEUE_LEN,(UBaseType_t)QUEUE_SIZE); 接收数据任务 1234567891011121314151617static void Receive_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE; uint32_t r_queue; while (1) &#123; //消息队列句柄，缓冲区，等待时间：一直等待 xReturn = xQueueReceive(Test_Queue,&amp;r_queue,portMAX_DELAY); if(xReturn==pdTRUE) &#123; printf(&quot;本次接收到的消息是%d\\r\\n&quot;,r_queue); &#125;else &#123; printf(&quot;数据接收错误，错误代码:0x%l\\r\\n&quot;,xReturn); &#125; &#125;&#125; Button控制发送数据任务 12345678910111213141516171819202122232425262728293031static void Send_Task(void *paramter)&#123; BaseType_t xReturn=pdTRUE; uint32_t send_data1=1; uint32_t send_data2=2; while (1) &#123; if (Key_BTN(BTN1)==KEY_ON) &#123; printf(&quot;发送消息send_data1\\r\\n&quot;); //消息队列句柄，数据，等待时间：0 xReturn = xQueueSend(Test_Queue,&amp;send_data1,0); if (xReturn==pdTRUE) &#123; printf(&quot;消息send_data1发送成功\\r\\n&quot;); &#125; &#125; if (Key_BTN(BTN2)==KEY_ON) &#123; printf(&quot;发送消息send_data2\\r\\n&quot;); xReturn = xQueueSend(Test_Queue,&amp;send_data2,0); if (xReturn==pdTRUE) &#123; printf(&quot;消息send_data2发送成功\\r\\n&quot;); &#125; &#125; vTaskDelay(20); &#125;&#125; ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-02-任务管理","slug":"FreeRTOS-02-任务管理","date":"2023-06-30T02:23:38.000Z","updated":"2023-06-30T02:26:10.123Z","comments":true,"path":"2023/06/30/FreeRTOS-02-任务管理/","link":"","permalink":"http://example.com/2023/06/30/FreeRTOS-02-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/","excerpt":"","text":"任务管理系统中任务运行调度方式 每个任务都是在独立的堆栈环境运行，运行的任务越多需要的堆栈空间越多。 任务之间的切换是基于抢占优先级的，高优先级抢占低优先级 任务切换的寻找方式 基于链表，从高往低查，任务创建时已经完成排序 计算前导零指令CLZ​，直接读出优先级任务(stm32​使用这种方式) 相同优先级任务则采用时间片轮转，无更高优先级任务情况下。 任务状态创建的任务一般有四种状态 就绪态：新创建的任务处于该状态，等待调度器调度 运行态：正在运行的任务，运行的是最高优先级的就绪态任务 阻塞态：不在就绪态列表中，处于中断或等待 挂起态： 挂起态任务调度器不可见 使用vTaskSuspend()​进入挂起态 使用vTaskResume()​或vTaskResumeFromISR()​从挂起态恢复 和阻塞态的区别在于：挂起态用于长时间不处理的任务；阻塞态的任务系统需要判断是否超时​ 常见任务操作函数 vTaskSuspend()​任务挂起：等效于该任务被“冻结”或者“休眠” vTaskSuspendAll()​全任务挂起 vTaskResume()​任务恢复：将被挂起的任务恢复 vTaskResumeFromISR()​中断专用任务恢复 无论使用几次vTaskSuspend()​，只需要使用一次恢复函数即可恢复 需要配置INCLUDE_vTaskResumeFromISR 1​的宏定义 vTaskResumeAll()​全任务恢复 vTaskDelete()​任务删除 vTaskDelay()​任务延时，延时时间为Systick​ vTaskDelayUntil()​任务绝对延时 设计一个任务管理通过2个Button​控制一个LED​灯任务的挂起和恢复，需要注意的是：按键检测最好设计成通用函数，保留GPIO​和Pin​让每个按键的检测尽量避免耦合 12345678910111213141516//按下状态,0为低有效道通,此处根据接线而定#define KEY_ON 0#define KEY_OFF 1uint8_t Key_Scan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)&#123; /*检测是否有按键按下 */ if(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON ) &#123; /*等待按键释放 */ while(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON ); return KEY_ON ; &#125; else return KEY_OFF;&#125; 建立一个按键检测的任务，根据按键检测来判断是否导通，然后其中一个按键用于挂起任务，另一个按键用于恢复任务。 12345678910111213141516171819202122static void KEY_Task(void *paramter)&#123; while(1) &#123; if( Key_Scan(GPIOB,GPIO_Pin_1) == 0 ) &#123; /* Button1 被按下 */ printf(&quot;按下开启键，LED0任务挂起\\r\\n&quot;); vTaskSuspend(LED0_Task_Handle);/* 挂起LED任务 */ printf(&quot;挂起成功\\r\\n&quot;); &#125; if( Key_Scan(GPIOB,GPIO_Pin_10) == 0 ) &#123; /* Button1 被按下 */ printf(&quot;按下关闭键，LED0任务恢复\\r\\n&quot;); vTaskResume(LED0_Task_Handle);/* 恢复LED任务！ */ printf(&quot;恢复成功\\r\\n&quot;); &#125; vTaskDelay(20); &#125;&#125; ‍ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"FreeRTOS-01-移植","slug":"FreeRTOS-01-移植","date":"2023-06-29T06:52:44.000Z","updated":"2023-06-29T06:57:32.061Z","comments":true,"path":"2023/06/29/FreeRTOS-01-移植/","link":"","permalink":"http://example.com/2023/06/29/FreeRTOS-01-%E7%A7%BB%E6%A4%8D/","excerpt":"","text":"堆和栈堆栈返回地址保存在栈中 添加串口打印功能 去掉无关代码、LCD等 增加串口打印功能 初始化串口 实现fputc 标准库移植将官方标准库移植到STM32F103C8T6 常见变量类型TaskHandle_t​是任务句柄类型，指针类型，原型为void *​ StackType_t​是任务堆栈类型，整型类型，原型为uint32_t​ StackTask_t​是任务块类型，结构体，原型为xSTATIC_TCB​结构体 移植注意事项FreeRTOSConfig.h配置中断服务 123456/**************************************************************** FreeRTOS与中断服务函数有关的配置选项,映射端口 ****************************************************************/#define xPortPendSVHandler PendSV_Handler#define vPortSVCHandler SVC_Handler Serial.c注意串口波特率一致性 尽量使用printf​而不使用自定义Serial_Printf​ main.c注意开启vTaskStartScheduler​ 创建任务静态SARM内存需要开启静态内存 12//支持静态内存#define configSUPPORT_STATIC_ALLOCATION 1 静态内存任务开启区函数 1234567LEDTask_Handle = xTaskCreateStatic((TaskFunction_t)LED_Task, //任务LED (const char*)&quot;LED_Task&quot;, //任务名 (uint32_t)128, //堆栈大小 (void*)NULL, //传给函数的参数 (UBaseType_t)4, //任务优先级 (StackType_t *)LED_Task_Stack, //任务堆栈 (StaticTask_t *)&amp;LED_Task_TCB); //任务控制块 动态SARM内存不开启静态内存 动态内存任务开启函数 123456xReturn = xTaskCreate((TaskFunction_t)LED_Task, //任务LED (const char*)&quot;LED_Task&quot;, //任务名 (uint16_t)512, //堆栈大小 (void*)NULL, //传给函数的参数 (UBaseType_t)2, //任务优先级 (TaskHandle_t *)&amp;LEDTask_Handle);//任务控制块指针 注意动态和静态的开启函数区别，参数不同，参数类型也不同。 多任务多任务相较于单任务，区别只在任务开启的个数，对应参数填好，开启任务即可实现多任务。 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"C52-day05","slug":"C52-day05","date":"2023-05-23T11:58:56.000Z","updated":"2023-05-23T11:59:34.006Z","comments":true,"path":"2023/05/23/C52-day05/","link":"","permalink":"http://example.com/2023/05/23/C52-day05/","excerpt":"","text":"高级定时器应用PWM调制LED灯并驱动电机代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/*time:2023-05-23PWM LED DC*/#include &lt;reg52.h&gt;#include &quot;Delay.h&quot;sbit LED=P1^0;sbit st = P3^0;sbit eoc = P3^1;sbit oe = P3^2;sbit RS = P3^3;sbit RW = P3^4;sbit E = P3^5;unsigned int vol = 0;unsigned char t[] = &#123;&quot;012346789&quot;&#125;;unsigned char str[] = &#123;&quot;VOLTAGE: &quot;&#125;;unsigned char i;unsigned char PWM_COUNT; //计数unsigned int HUXI_COUNT; //占空比更新时间unsigned char PWM_VLAUE; //占空比比对值bit direc_flag; //占空比更新方向// 写数据void writedate(unsigned int date)&#123; RS = 1; RW = 0; E = 0; P2 = date; Delay(5); E = 1; E = 0;&#125;// 写命令void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P2 = com; Delay(5); // 延时根据实际效果判断 E = 1; E = 0;&#125;// 初始化void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void timer0_init()&#123; TMOD=0x02; //模式设置，00100000，定时器0，工作于模式2（M1=1，M0=0）//定时器溢出值设置，每隔50ms发起一次中断。 TH0=(65536-50000)/256; TL0=(65536-50000)%256; TR0=1; //定时器0开始计时 ET0=1; //开定时器0中断 EA=1; //开总中断 PWM_COUNT =0;&#125;void time0() interrupt 1&#123; PWM_COUNT++; HUXI_COUNT++; if(PWM_COUNT == PWM_VLAUE) //判断是否到了点亮LED的时候 LED = 1; //点亮LED if(PWM_COUNT == 40) //当前周期结束 &#123; LED = 0; //熄灭LED PWM_COUNT = 0; //重新计时 &#125; if((HUXI_COUNT == 200) &amp;&amp; (direc_flag == 0)) &#123; //占空比增加10% HUXI_COUNT = 0; PWM_VLAUE++; if(PWM_VLAUE == 39) //占空比更改方向 direc_flag = 1; &#125; if((HUXI_COUNT == 200) &amp;&amp; (direc_flag == 1)) &#123; //占空比减少10% HUXI_COUNT = 0; PWM_VLAUE--; if(PWM_VLAUE == 1) //占空比更改方向 direc_flag = 0; &#125;&#125;void adc()&#123; // 开启START st = 0; st = 1; Delay(5); st = 0; while (eoc != 1); oe = 1; vol = P0; oe = 0; &#125; void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0; int i = 0; vol = vol * 100 / 51; temp0 = vol/100; temp1 = (vol%100)/10; temp2 = vol%10; writecom(0x80); Delay(5); for(i=0; i&lt;8; i++) &#123; writedate(str[i]); Delay(5); &#125; writecom(0x80 + 0x40 + 4); Delay(5); writedate(t[temp0]); Delay(5); writedate(&#x27;.&#x27;); Delay(5); writedate(t[temp1]); Delay(5); writedate(t[temp2]); Delay(5); writedate(&#x27;V&#x27;); Delay(5); &#125;void main()&#123; HUXI_COUNT = 0; PWM_COUNT = 0; PWM_VLAUE = 20; direc_flag = 0; LED = 1; //默认LED熄灭 timer0_init(); //定时器0初始化 initlcd(); while(1)&#123;// Delay(100);// LED=~LED; adc(); display(); &#125;&#125;//Delay.c#include &lt;intrins.h&gt;#include &lt;reg52.h&gt;#include &quot;Delay.h&quot;// 延迟1msvoid Delay(unsigned int n)&#123;//@11.0592MHz unsigned char i, j;//for(j=n;j&gt;0;j--)//for(i=112;i&gt;0;i--); while(n--) &#123; i = 2; j = 239; do &#123; while (--j); &#125; while (--i); &#125;&#125;//Delay.h#ifndef __Delay_H__#define __Delay_H__void Delay(unsigned int times);#endif ​ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day04","slug":"C52-day04","date":"2023-05-16T10:52:48.000Z","updated":"2023-05-16T10:53:18.567Z","comments":true,"path":"2023/05/16/C52-day04/","link":"","permalink":"http://example.com/2023/05/16/C52-day04/","excerpt":"","text":"AD转换‍ 代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/*time:2024-05-16数字电压表*/# include &quot;reg51.h&quot;sbit st = P3^0;sbit eoc = P3^1;sbit oe = P3^2;sbit RS = P3^3;sbit RW = P3^4;sbit E = P3^5;unsigned int vol = 0;unsigned char t[] = &#123;&quot;012346789&quot;&#125;;unsigned char str[] = &#123;&quot;VOLTAGE: &quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;// 写数据void writedate(unsigned int date)&#123; RS = 1; RW = 0; E = 0; P1 = date; delay(5); E = 1; E = 0;&#125;// 写命令void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P1 = com; delay(5); // 延时根据实际效果判断 E = 1; E = 0;&#125;// 初始化void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void adc()&#123; // 开启START st = 0; st = 1; delay(5); st = 0; while (eoc != 1); oe = 1; vol = P2; oe = 0; &#125; void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0; int i = 0; vol = vol * 100 / 51; temp0 = vol/100; temp1 = (vol%100)/10; temp2 = vol%10; writecom(0x80); delay(5); for(i=0; i&lt;8; i++) &#123; writedate(str[i]); delay(5); &#125; writecom(0x80 + 0x40 + 4); delay(5); writedate(t[temp0]); delay(5); writedate(&#x27;.&#x27;); delay(5); writedate(t[temp1]); delay(5); writedate(t[temp2]); delay(5); writedate(&#x27;V&#x27;); delay(5); &#125;void main()&#123; initlcd(); while(1) &#123; adc(); display(); &#125;&#125; ​ 直流电机 直流电机的控制： 方向控制：直流电机只有正负极，只需交换正负极就可以调节正反转。 转速控制：负载变化不大的时候，加在直流电动机两端的电压大小与其速度近似成正比。 PWM技术： 电动机的电枢绕组两端的电压平均值U为：$D &#x3D; \\frac{t_1}{T}U&#x3D;DU_s$ D为PWM的占空比：$D &#x3D; \\frac{t_1}{T}$ 占空比：一个周期之内高电平的时间与整个周期时长之比。范围：0~1 L293D 芯片： 顺时针转动：最大转速192 代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*time:2023-05-1651单片机对直流电机的控制*/# include &quot;reg51.h&quot;typedef unsigned int uint;sbit IN0 = P2^0;sbit IN1 = P2^1;sbit E = P2^2;void motor()&#123; IN0 = 1; IN1 = 0; E = 1;&#125;void inittimer()&#123; TMOD = 0X01; TH0 = (65536 - 10000)/256; TL0 = (65536 - 10000)%256; ET0 = 1; EA = 1; TR0 = 1; IN1 = 0;&#125;/*void timer_isr() interrupt 1&#123; TH0 = (65536 - 10000)/256; TL0 = (65536 - 10000)%256; // 占空比：%50 IN1 = ~IN1;&#125;*/void main()&#123; inittimer(); while(1) &#123; motor(); &#125;&#125; ​ 步进电机 驱动芯片：L298 四相步进电机四步法和八步法：四步法：给ABCD引脚给控制信号：1001、1100、0110、0011步进电机顺时针转动。八步法：四步法的一半，1001、1000、1100、0100、0110、0010、0011、0001 四步法转动角度大，更平滑。八步法转读角度小，但是能够实现更高的转速 代码​ 123456789101112131415161718192021222324252627282930313233343536373839/*time:2023-05-16步进电机*/# include &quot;reg51.h&quot;typedef unsigned char uchar;typedef unsigned int uint;uchar st[] = &#123;0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01&#125;;void delay(uint n)&#123; uint i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void stepper()&#123; int i = 0; for (i=7; i&gt;0; i--) // 反转 每次转动45° &#123; P2 = st[i]; delay(100); &#125; &#125;void main()&#123; while(1) &#123; stepper(); &#125;&#125; ​ ‍ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day03","slug":"C52-day03","date":"2023-05-11T01:42:43.000Z","updated":"2023-05-11T01:45:49.992Z","comments":true,"path":"2023/05/11/C52-day03/","link":"","permalink":"http://example.com/2023/05/11/C52-day03/","excerpt":"","text":"虚拟串口代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* time:2023-05-10COM*/# include &quot;reg51.h&quot;unsigned char recdat = 0, flag = 0;void initscon()&#123; SCON = 0X50; // 0101 0000 TMOD = 0X20; // 0010 0000 TH1 = 256 - 3; TL1 = 256 - 3; ES = 1; EA = 1; TR1 = 1;&#125;void scon_isr() interrupt 4 // COM interrupt&#123; recdat = SBUF; RI = 0; flag = 1; &#125;void senddat()&#123; SBUF = recdat; while(!TI); TI = 0;&#125;void main()&#123; initscon(); while(1) &#123; if (flag == 1) &#123; senddat(); flag = 0; &#125; &#125;&#125; ​ LCD1602常用指令码 0X38:设置16 * 2 显示，5*7点阵， 8位数据接口 0X0C：设置开显示，不显示光标 0X06:写一个字符后地址指针加1 0X01: 显示清0，数据指针清0 0X80:LCD第一行的起始地址 0X80+0X40:LCD第二行的起始地址 ‍ LCD1602功能 RS​，片选 RS=0​，输入命令，不显示字符 RS=1​，写入数据，显示字符 RW​，读写操作 RW=0​，写操作 RW=1​，读操作 E​，使能端，高电平有效 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* time:2023-05-10LCD display*/# include &quot;reg51.h&quot;sbit RS = P3^0;sbit RW = P3^1;sbit E = P3^2;unsigned char str[] = &#123;&quot;xuaner&quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;// write signvoid writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; //P3^2 is low ---&gt;E is high P2 = com; delay(5); // delay E = 1; E = 0;&#125;// write Datavoid writedate(unsigned char date)&#123; RS = 1; RW = 0; E = 0; P2 = date; delay(5); E = 1; E = 0;&#125;// initialvoid initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void display()&#123; unsigned int i = 0; writecom(0x80); // second line：0x80 + 0x40 delay(5); /* one Char display writedate(&#x27;x&#x27;); delay(5); writedate(&#x27;u&#x27;); delay(5); writedate(a&#x27;); delay(5); writedate(&#x27;n&#x27;); delay(5); writedate(e&#x27;); delay(5); writedate(&#x27;r&#x27;); delay(5); */ // string display while (str[i] != &#x27;\\0&#x27;) &#123; writedate (str[i]); delay(5); i++; &#125; &#125;void main()&#123; initlcd(); while(1) &#123; display(); &#125;&#125; ​ LCD时钟代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/*time:2023-05-10simple clk*/# include &quot;reg51.h&quot;sbit RS = P3^0;sbit RW = P3^1;sbit E = P3^2;unsigned char count = 0;unsigned int hour = 9, min = 54, sec = 0;unsigned char str[] = &#123;&quot;0123456789&quot;&#125;;unsigned char str1[] = &#123;&quot;xuaner CLK&quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P2 = com; delay(5); E = 1; E = 0;&#125;void writedate(unsigned char date)&#123; RS = 1; RW = 0; E = 0; P2 = date; delay(5); E = 1; E = 0;&#125;void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0, temp5 = 0; unsigned char i = 0; temp0 = hour / 10; temp1 = hour % 10; temp2 = min / 10; temp3 = min % 10; temp4 = sec / 10; temp5 = sec % 10; writecom(0X80); delay(5); while(str1[i] != &#x27;\\0&#x27;) &#123; writedate(str1[i]); delay(5); i++; &#125; writecom(0X80 + 0X40 + 4); delay(5); writedate(str[temp0]); delay(5); writedate(str[temp1]); delay(5); writedate(&#x27;:&#x27;); delay(5); writedate(str[temp2]); delay(5); writedate(str[temp3]); delay(5); writedate(&#x27;:&#x27;); delay(5); writedate(str[temp4]); delay(5); writedate(str[temp5]); delay(5); &#125;void inittimer()&#123; TMOD = 0x01; TH0 = (65536-50000)/256; // 50ms TL0 = (65536-50000)%256; ET0 = 1; EA = 1; TR0 = 1;&#125;void timer0_isr() interrupt 1&#123; TH0 = (65536-50000)/256; // 50ms TL0 = (65536-50000)%256; count++; if (count == 20) // 1s &#123; sec = sec + 1; count = 0; &#125; if (sec == 60) &#123; min = min + 1; sec = 0; &#125; if (min == 60) &#123; hour = hour + 1; min = 0; &#125; if (hour == 24) &#123; hour = 0; &#125;&#125;void main()&#123; initlcd(); inittimer(); while(1) &#123; display(); &#125;&#125; ​ 点阵显示代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*time:2023-05-10matrix*/# include &quot;reg51.h&quot;unsigned char code tab[] = &#123; 0x00, 0x7e, 0xff, 0xc3, 0xc3, 0xff, 0x7e, 0x00, // 0 0x00, 0x00, 0x43, 0xff, 0xff, 0x03, 0x00, 0x00, // 1 0x00, 0x63, 0xc7, 0xcf, 0xdb, 0xf3, 0x63, 0x00, // 2 0x00, 0x42, 0xdb, 0xdb, 0xdb, 0xff, 0x66, 0x00, // 3 0x00, 0x3e, 0x46, 0xff, 0xff, 0x06, 0x06, 0x00, // 4 &#125;; unsigned char row[] = &#123;0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80&#125;;unsigned char num = 0, flag = 0;sbit key0 = P1^0;void key()&#123; if (flag == 0 &amp;&amp; key0 == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; num++; flag = 0; &#125; if (num == 5) &#123; num = 0; &#125;&#125;void matrix()&#123; unsigned int i = 0; for (i=8*num; i&lt;8*(num+1); i++) &#123; P3 = ~row[i-8*num]; P2 = tab[i]; &#125;&#125;void main()&#123; while(1) &#123; matrix(); key(); &#125;&#125; ​ ‍ DA转换代码​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*time:2023-05-10DA*/# include &quot;reg51.h&quot;unsigned int value = 100, flag = 0;sbit key0 = P1^0;sbit key1 = P1^1;void key()&#123; if (key0 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; value += 10; flag = 0; &#125; if (key1 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key1 == 1) &#123; value -= 10; flag = 0; &#125;&#125;void delay(unsigned int n)&#123; int i=0, j=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;/* pwmvoid PWM()&#123; P2 = 0;delay(100); // duty cycle :change delay P2 = 255; delay(value);&#125;*/void stair()&#123; int i = 0; for (i=0; i&lt;255; i++) &#123; P2 = i; &#125; for (i=255; i&lt;0; i--) &#123; P2 = i; &#125;&#125;void main()&#123; while(1) &#123; // PWM(); stair(); // sawtooth wave key(); &#125;&#125;","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day02","slug":"C52-day02","date":"2023-05-10T00:29:19.000Z","updated":"2023-05-11T01:45:03.314Z","comments":true,"path":"2023/05/10/C52-day02/","link":"","permalink":"http://example.com/2023/05/10/C52-day02/","excerpt":"","text":"矩阵键盘代码​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*time:2023-05-08array buttons */# include &quot;reg51.h&quot;unsigned int num = 9;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F,0X76, 0X79, 0X38, 0X38, 0X3F,0XFF&#125;; // 0-9sbit P10=P1^0;sbit P11=P1^1;sbit P12=P1^2;sbit P13=P1^3;sbit P14=P1^4;sbit P15=P1^5;sbit P16=P1^6;sbit P17=P1^7;void Delay(unsigned int n)&#123; unsigned int i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void key_scan()&#123; P1 = 0xff; /*---------------cycle scan-----------------*/ P1=0xFF; P13=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=1;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=5;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=9;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=13;&#125; P1=0xFF; P12=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=2;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=6;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=10;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=14;&#125; P1=0xFF; P11=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=3;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=7;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=11;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=15;&#125; P1=0xFF; P10=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=4;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=8;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=12;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=16;&#125; &#125;void display()&#123; P2 = s[num];&#125;void main()&#123; while(1) &#123; key_scan(); display(); &#125;&#125; ​ 定时器工作方式 interrupt0，13位，当 INT0 引脚由高电平变为低电平时触发中断。 $X&#x3D;8192-N\\frac{12}{fosc}$​ 上次计数为0，要重复计数需要置零 interrupt1，16位，当定时器 0 计数器溢出时触发中断。 $X&#x3D;65536-N\\frac{12}{fosc}$​ 上次计数值为0，要重复计数需要重置初值 interrupt2，8位自动重置定时&#x2F;计数器，当 INT1引脚由高电平变为低电平时触发中断。 interrupt3，8位，只有T0才能使用，当定时器 1 计数器溢出时触发中断。 $X&#x3D;256-N\\frac{12}{fosc}$​ 计数器自动配置初值，不需要用户重置 interrupt4，串口中断，当串口接收完成（RI）或发送完成（TI）时触发中断。 TMOD 寄存器TMOD 的低 4 位控制定时器 0，高 4 位控制定时器 1，每个定时器都有两个工作模式可以选择 M0表示定时器0，M1表示定时器1 TMOD&#x3D;0x20表示定时器1设置为2模式 TMOD&#x3D;0x02表示定时器0设置为2模式 TMOD GATE C&#x2F;T M1 M0 工作模式 0x00 0 0 0 0 模式 0：13 位计数器 0x01 0 0 0 1 模式 1：16 位计数器 0x02 0 0 1 0 模式 2：8 位自动重装载计数器 0x03 0 0 1 1 模式 3：16 位自动重装载计数器 0x04 0 1 0 0 模式 4：外部事件计数 0x05 0 1 0 1 模式 5：保留 0x06 0 1 1 0 模式 6：8 位 PWM 波形发生器 0x07 0 1 1 1 模式 7：16 位 PWM 波形发生器 TH和TL寄存器 TH0/TL0​表示定时器0的高低八位 TH1/TL1​表示定时器1的高低八位 IT寄存器 IT0​，外部中断寄存器 IT1​，外部中断寄存器 IT0/IT1=0​​，低电平触发 IT0/IT1=1​​，下降沿触发 中断寄存器 ET0/ET1​，定时器中断使能寄存器，为1中断允许，为0不允许 EA​，总中断使能寄存器，为1中断允许，为0不允许 TR0/TR1​，定时器启动控制寄存器，为1时开始计数，为0时停止计数。 ‍ 12MHz晶振对应的一个机器周期为1us，需要延时50ms，则从65536-50000开始计数，分为高低八位分别存储计数，当定时器0计数到65536溢出位时，触发timer_isr中断，执行函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*time: 2023-05-08timer*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f&#125;;unsigned char count = 0, num = 0;void inittimer()&#123; TMOD = 0x01; // 0000 0001 TH0 = (65536 - 50000) / 256; // 50ms = 50000us initial value &gt;&gt; 8 TL0 = (65536 - 50000) % 256; ET0 = 1; /* timer0 interrupt on*/ EA = 1; // interrupt on TR0 = 1; //timer0 on&#125;void display()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;/* 0 out interrupt0； 1 timer interrupt0；2 out interrupt1；3 timer interrupt1；4 COM interrupt*/void timer_isr() interrupt 1 &#123; TH0 = (65536 - 50000) / 256; // 50ms = 50000us initial value &gt;&gt; 8 TL0 = (65536 - 50000) % 256; count++; if (count == 20) // setTime 1s &#123; num++; count = 0; &#125;&#125;void main()&#123; inittimer(); while(1) &#123; display(); &#125;&#125; ​ 计数器代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142/*time:2023-05-088bit auto reset count*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f&#125;;unsigned char num = 0;void initcounter()&#123; TMOD = 0X06; // 0000 0110 auto reset TH0 = 255; TL0 = 255; ET0 = 1; EA = 1; TR0 = 1;&#125;void display()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;void counter_isr() interrupt 1&#123; num++;&#125;void main()&#123; initcounter(); while(1) &#123; display(); &#125;&#125; ​ ‍ ‍ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day01","slug":"C52-day01","date":"2023-05-08T08:16:11.000Z","updated":"2023-05-08T08:24:21.577Z","comments":true,"path":"2023/05/08/C52-day01/","link":"","permalink":"http://example.com/2023/05/08/C52-day01/","excerpt":"","text":"STC89C52命名规则STC89C52 STC89 C–&gt;工作电压 C：5.5V~3.8V LE:3.6V2.4V&#x2F;3.4V\\2.4V 52表示8K字节程序空间，512字节RAM 最小系统​ LED灯代码​ 1234567891011121314151617181920212223242526272829303132333435/*time: 2023-05-07C Flowing LED*/# include &quot;reg51.h&quot;// define an array of reg P0//unsigned char leds[] = &#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(unsigned int n)&#123; unsigned int i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void led()&#123; int i = 0; for (i=0; i&lt;8; i++) &#123; P2 = ~(0x01&lt;&lt;i); //P2 = ~leds[i]; delay(500); &#125;&#125;void main() &#123; while(1) &#123; led(); &#125;&#125; ​ 数码管数码管16进制显示数码管对应16进制0~F 共阳极数码管 12unsigned char LED7Code[] = &#123;0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e&#125;; 共阴极数码管 12unsigned char LED7Code[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d, 0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;; 普通数码管代码​ 12345678910111213141516171819202122232425262728293031323334353637383940/*time: 2023-05-07C LED Display*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F&#125;; // common cathode 0-9/* &#123;0X77, 0X7C, 0X39, 0X5E, 0X79, 0X71, 0X73, 0X3E, 0X31, 0X6E,&#125; &#123;0X38, 0X00&#125;static display 0-9 A-F P U T Y L */void delay(unsigned char n)&#123; unsigned char i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void smg()&#123; int i = 0; for (i=0; i&lt;10; i++) &#123; P2 = s[i]; delay(1000); &#125;&#125;void main()&#123; while(1) &#123; smg(); //P2=0X06; &#125;&#125; ​ 组合74LS13874LS138对数码管进行片选 1234567891011121314151617181920212223242526272829303132333435363738394041/* time:2023-05-07 74LS138 display HELLO*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0X76, 0X79, 0X38, 0X38, 0X3F&#125;; // common cathode HELLOunsigned char sbi[] = &#123;0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07&#125;; //74LS138 chip select/* &#123;0X77, 0X7C, 0X39, 0X5E, 0X79, 0X71, 0X73, 0X3E, 0X31, 0X6E,&#125; &#123;0X38, 0X00&#125;0-9 A-F P U T Y L */void delay(unsigned char n)&#123; unsigned char i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void smg()&#123; int i = 0; for (i=0; i&lt;5; i++) &#123; P3 = sbi[i]; P2 = s[i]; delay(10); &#125;&#125;void main()&#123; while(1) &#123; smg(); &#125;&#125; ​ 按钮控制数码管代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142/*time:2023-05-07LED button control*/# include &quot;reg51.h&quot;sbit key0 = P1^0;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F&#125;; // 0-9unsigned char num = 0;unsigned char flag = 0;void key()&#123; if (key0 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; num++; flag = 0; &#125;&#125;void seg()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;void main()&#123; while(1) &#123; key(); seg(); &#125;&#125; ​","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"前端IC——数电基础","slug":"前端IC——数电基础","date":"2023-01-08T10:58:54.000Z","updated":"2023-01-08T10:59:41.802Z","comments":true,"path":"2023/01/08/前端IC——数电基础/","link":"","permalink":"http://example.com/2023/01/08/%E5%89%8D%E7%AB%AFIC%E2%80%94%E2%80%94%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"信息、编码和逻辑代数信息是用来消除不确定的东西✨ 编码是一种映射或者描述关系。 常见编码：余三码、补码、反码、8421码、格雷码 反码：除符号位外，按位取反 补码：除符号位外，按位取反然后加1 正数的反码和补码都是其本身 逻辑代数计算： (AB)’ = A’ + B’ ​ (A + B)’ = A’B’​ 组合逻辑、时序逻辑电路组合逻辑电路：是任意时刻的输出仅仅取决于当前时刻的输入，与电路之前的历史状态无关（即无记忆能力） 组合逻辑电路的设计通常包含以下几个步骤： 进行逻辑抽象。分析事件的因果关系，确定输入变量和输出变量，列出输入变量和输出变量的逻辑真值表。 写出逻辑函数。将真值表转换为对应的逻辑函数式，或者直接画出卡诺图，然后使用第三章中介绍的卡诺图将逻辑函数进行化简。 根据化简后的逻辑函数，画出逻辑电路图。 时序逻辑电路：输出不仅取决于当前的输入，还取决于电路的历史状态。 因此我们需要一种元件能保存电路的状态信息。如果一个元件带有内部存储功能，它就包含状态，也称之为状态单元（State Element）。 锁存器：锁存器在E的高(低)电平期间对信号敏感触发器：触发器在CP的上升沿(下降沿)对信号敏感二者区别： 具有0 和1两个稳定状态，一旦状态被确定，就能自行保持。一个锁存器或触发器能存储一位二进制码。 锁存器—对脉冲电平敏感的存储电路，在特定输入脉冲电平作用下改变状态。 触发器—对脉冲边沿敏感的存储电路，在时钟脉冲的上升沿或下降沿的变化瞬间改变状态。 ‍ 亚稳态、稳定时间、保持时间建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的最小时间。 保持时间​：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的最小时间。 建立时间裕量：如果数据信号在时钟边沿触发之前的持续时间要大于建立时间Tsu，那么超出的部分时间即为建立时间裕量。 保持时间裕量：如果数据信号在时钟边沿触发之后的保持时间要大于保持时间Thd，那么超出的部分时间即为保持时间裕量。 ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数字IC/数电","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E6%95%B0%E7%94%B5/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数电","permalink":"http://example.com/tags/%E6%95%B0%E7%94%B5/"}],"author":"xuaner"},{"title":"静态时序分析——建立保持时间","slug":"静态时序分析——建立保持时间","date":"2023-01-03T06:05:42.000Z","updated":"2023-01-03T07:01:57.625Z","comments":true,"path":"2023/01/03/静态时序分析——建立保持时间/","link":"","permalink":"http://example.com/2023/01/03/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4/","excerpt":"","text":"建立时间公式 $$T_{lanuch}+T_{ck2q}+T_{dp}&lt;T_{capture}+T_{cycle}-T_{setup}$$ ​ 如果组合逻辑的延时最大值也满足这个公式，则所有都满足，通常用组合逻辑最大延时检查建立时间 使用组合逻辑最小延时检查保持时间 输入端口到寄存器公式 $$slack&#x3D;T_{capture}+T_{cycle}-T_{setup}-T_{uncertainty}-(T_{lanuch}+T_{ck2q}+T_{dp})&gt;0$$ ​ 输出端口到寄存器公式 $$slack&#x3D;T_{capture}+T_{cycle}-T_{setup}-T_{uncertainty}-T_{output_delay}-(T_{lanuch}+T_{ck2q}+T_{dp})&gt;0$$ ​ 保持时间 捕获路径边沿比发射路径边沿晚一个时钟周期 保持时间和时钟周期无关 保持时间不能计算频率，只能用建立时间去计算 公式 $$T_{lanuch}+T_{ck2q}+T_{dp}&gt;T_{capture}+T_{hold}$$ ​ 建立时间和保持时间的区别 保持时间的检查边沿都是同一个边沿 建立时间的检查边沿捕获的边沿要比发射的边沿晚一个时钟周期 保持时间的检查通常在建立时间检查的前一个上升沿","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"静态时序分析——逻辑综合","slug":"静态时序分析——逻辑综合","date":"2022-12-27T10:33:14.000Z","updated":"2022-12-27T10:34:52.675Z","comments":true,"path":"2022/12/27/静态时序分析——逻辑综合/","link":"","permalink":"http://example.com/2022/12/27/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88/","excerpt":"","text":"逻辑综合三个阶段：转译、优化、映射 时序路径约束 输入到寄存器的路径 寄存器到寄存器之间的路径 寄存器到输出的路径 输入直接到输出的路径 12create_clock-period 10 [get_ports Clk]set_dont_touch_network [get_clocks Clk] 对所有定义的时钟网络设置为dont_touch​，即综合的时候不对Clk​信号优化。 如果不加这句，DC会根据CIk的负载自动对他产生Buffer​，而在实际的电路设计中，时钟树（Clock Tree）的综合有自己特别的方法，它需要考虑到实际布线后的物理信息，所以DC不需要在这里对它进行处理，就算处理了也不会符合要求。 12345#定义输入延迟set_input_delay -max 4-clock Clk [get_ports A]#定义输出延迟set_output_delay -max 5.4 -clock Clk [get_ports B] TCL脚本1234567891011sh date //显示开始时间remove_design-designs //移除DC中原有的设计//下面是库的设置，对应图形界面操作的2###########井#############井#set library############井####井##井#####井set search_path [list *********]set target_library &#123;tt.db&#125; set link_library &#123;*tt.db&#125; set symbol_library &#123;tt.sdb&#125; 123456789101112//下面是屏蔽一些warning信息，DC在综合时遇到这些warning时就把它们忽略，//不会报告这些信息，VER-130，VER-129等是不同warning信息的编码，//具体含义可以查看帮助#void warning Info#############suppress_message VER-130suppress_message VER-129suppress_message VER-318suppress_message ELAB-311suppress_message VER-936 123456789//读入example1.v文件，对应于图形界面的3##################################read&amp;amp；link&amp;amp；Check design#read_file -format verilog ~/example1.v#analyze -format verilog ~/example1.v#elaborate EXAMPLE1current_design EXAMPLE1 //把EXAMPLE1指定为当前设计的顶层模块uniquify check design 12345678910//设置一些变量#############################define IO port name#############################set clk[get_ports clk] //设置变量clk的值是[get_ports clk],//在下面的代码中若出现$clk字样，则表示引用该变量的值，即用[get_ports clk]代替$clk。set rst_n [get_ports rst_n]set general_inputs [list a b c]set outputs [get_ports o] 1234567891011/设置约束条件，对应于图形界面的4#set_constraints#############################井//设置时钟约束，对应于图形界面的4.1#1 set constraints for clock signals create_clock -n clock $clk -period 20 -waveform&#123;0 10&#125; //创建一个周期为20ns，占空比为1的时钟set_dont_touch_network[get_clocks clock]set_drive 0 $clk //设置时钟端口的驱动为无穷大set_ideal_network [get_ports clk] //设置时钟端为理想网络 12345//设置复位信号约束，对应于图形界面的4.2#2 set constraints for reset signals set_dont_touch_network $rst_n set_drive 0 $rst_n set_ideal network[get_ports rst_n] 12345678//设置输入延时，对应图形界面的4.3#3 set input delay set_input_delay -clock clock 8$general_inputs/设置输出延时，对应图形界面的4.4#4 set output delay set_output_delay -clock clock 8$outputs 123456//设置面积约束和设计约束，对应图形界面的4.5#5 set design rule constraintsset_max_fanout 4 $general_inputs set_max_transition 0.5 [get_designs &quot;EXAMPLE1&quot;]#6 set area constraint set_max_area 0","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"常见电路","slug":"常见电路","date":"2022-12-22T07:36:15.000Z","updated":"2022-12-22T07:39:58.031Z","comments":true,"path":"2022/12/22/常见电路/","link":"","permalink":"http://example.com/2022/12/22/%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/","excerpt":"","text":"4选一​ 123456789101112131415161718192021222324252627282930//两种，一种使用assign赋值语句，用三目运算符嵌套，不便于阅读`timescale 1ns/1nsmodule mux4_1(input [1:0]d1,d2,d3,d0,input [1:0]sel,output [1:0]mux_out);assign mux_out = (sel == 2&#x27;b00) ? d3 : ((sel == 2&#x27;b01) ? d2 : (sel == 2&#x27;b10) ? d1 : d0);endmodule//使用case语句`timescale 1ns/1nsmodule mux4_1(input [1:0]d1,d2,d3,d0,input [1:0]sel,output [1:0]mux_out);reg [1:0] mux_out_reg;always @ (*)begin case(sel) 2&#x27;b00:mux_out_reg = d3; 2&#x27;b01:mux_out_reg = d2; 2&#x27;b10:mux_out_reg = d1; 2&#x27;b11:mux_out_reg = d0; default : mux_out_reg = d0; endcaseendassign mux_out = mux_out_reg;endmodule ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"常见器件","slug":"数字IC/常见器件","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"常见器件","slug":"常见器件","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"}],"author":"xuaner"},{"title":"芯动力——同步时序电路","slug":"芯动力——同步时序电路","date":"2022-12-14T12:41:35.000Z","updated":"2023-01-03T07:08:31.367Z","comments":true,"path":"2022/12/14/芯动力——同步时序电路/","link":"","permalink":"http://example.com/2022/12/14/%E8%8A%AF%E5%8A%A8%E5%8A%9B%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF/","excerpt":"","text":"同步电路设计同步时钟电路的优点： 在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中竞争冒险现象。 由于触发器只有在时钟边缘才改变取值，很大限度地减少了整个电路受毛刺和噪声影响的可能。 亚稳态 亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。 当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。（电路在翻转的时候） 在这个期间，触发器输出一当中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。 亚稳态不能从根本上消除，但是可以降低影响 $MTBF&#x3D;\\frac{e^{t_{MET}&#x2F;C_2}}{C_1f_{CLK}f_{DATA}}$​ $t_{MEF}$寄存器从时钟上升沿触发后的时序余量时间 指正常没有亚稳态情况下，寄存器输出信号从源寄存器到目的寄存器的建立时间余量。$f_{CLK}$接收时钟域的时钟频率$f_{DATA}$数据的变化频率$C_1$、$C_2$与器件有关的参数 为了避免上节所述的亚稳态问题，就应当使参数MTBF​尽可能的大，通常采用的方法是双锁存器法，即在一个信号进入另一个时钟域之前，将该信号用两个锁存器连续锁存两次，最后得到的采样结果就可以消除亚稳态问题。 ​ 优缺点​ 结构简单、易实现。 增加了两级触发器延时 当快时钟域转到慢时钟域时，易造成慢时钟采样丢失（还未来得及采样，数据就变化了）。故常用于慢时钟域转到快时钟域 两级触发器已经将MTBF变得足够大 三级或者更多级虽然能将亚稳态出现概率降得更低，但是影响电路效率 边沿检测同步器从慢时钟转变为快时钟 适用条件： 输入数据的宽度必须比一个接受时钟周期加上一个同步触发器的old时间要长，最安全的就是两个同步周期宽度。 ​ ‍ 脉冲同步器从快时钟变为慢时钟 ​ 同步器比较 类型 应用 输入 输出 限制 电平检测 同步电平信号时钟域任何时钟域的传输 电平 电平 输入信号必须保持两个接受时钟周期宽度每一次同步之后输入信号必须恢复到无效状态 边沿检测 检测输入信号的上升沿和下降沿适用于低频时钟域向高频时钟域传输 电平或脉冲 脉冲 输入信号必须保持两个接受时钟周期宽度 脉冲检测 同步单周期脉冲信号适用于高频时钟域向低频时钟域传输 脉冲 脉冲 输入的脉冲时间的距离必须保持两个接收时钟周期以上 ‍单bit信号跨时钟域传输 信号从快时钟域到慢时钟域过渡时，慢时钟将可能无法对变化太快的信号实现正确采样 上述同步器法对两个时钟之间的关系要求很严格，而“结绳法”适合任何时钟域的过渡。 将快时钟信号的脉冲周期延长，等到慢时钟同步采样后再“解绳”，还原为原来的脉冲周期宽度。 在慢时钟采样快时钟的时候，结绳法适合采样数据较少即脉冲间隔较大的控制信号。即脉冲间隔Ta&gt;3Tb；即等待3个clkB时钟后，完成复位，才允许下一个输入脉冲。 快时钟到慢时钟结绳就是将单脉冲延长，以方便采集到数据 利用脉冲的边沿做时钟 利用脉冲的电平（部分场合要求最小脉冲宽度）做选择器或者异步复位，置位。 另外的关键点就是什么时候结绳结束（采集到了数据就要让对方回到初始状态） 利用采集到的脉冲做异步复位，置位 利用采集到的脉冲再次结绳采集做握手响应信号 特点 结绳法可以解决快时钟域向慢时钟域过渡的问题，且其适用的范围很广 结绳法实现较为复杂，特别是其效率不高，在对设计性能要求较高的场合应该慎用 数据流数据流大多具有连续性，即背靠背传输；数据流要求信号具有较快的传输速度； 通常使用SRAM​和FIFO​解决传输问题 打两拍将地址总线打两拍●为了避免亚稳态传播不能消除亚稳态现象●因为时钟异步，亚稳态不可避免，但是可以极大降低亚稳态传播的概率低频情况●STA不需要分析这里的异步时序，因为寄存器都可以在一拍内将亚稳态消除，恢复到正常0&#x2F;1态。高频情况●不一定，尤其在28m工艺以下，需要检查两级触发器的延迟保证延迟低，提高系统MTBF​。 ‍ 同步复位异步释放时序电路必须有复位，组合逻辑电路不需要复位 两段式FSM两段式FSM​描述方法其输出一般使用组合逻辑描述，而组合逻辑易产生毛刺等不稳定因素。 如果时序允许插入一个额外的时钟节拍，用于消除毛刺 当不允许使用额外节拍，则改为使用三段式FSM​ 三段式FSM​优势 使FSM​做到了同步寄存器输出 消除了组合逻辑输出的不稳定与毛刺的隐患 更利于时序路径分组 在FPGA/CPLD​等可编程逻辑器件上的综合与布局布线效果更佳 一段式、两段式、三段式分别使用1、2、3个always​块，反之则不成立","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"时序","slug":"时序","permalink":"http://example.com/tags/%E6%97%B6%E5%BA%8F/"}],"author":"xuaner"},{"title":"Markdown语法","slug":"Markdown语法","date":"2022-12-04T12:20:02.000Z","updated":"2023-01-03T07:09:13.887Z","comments":true,"path":"2022/12/04/Markdown语法/","link":"","permalink":"http://example.com/2022/12/04/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"标题123# 一级标题## 二级标题### 三级标题 列表123456+ 无序列表1+ 无序列表2- 无序列表3- 无序列表4* 无序列表5* 无序列表6 121. 有序列表12. 有序列表2 123* [ ] 任务列表1* [ ] 任务列表2* [ ] 任务列表3 块123456‍``` 代码块‍````标记块`&gt; 引述 超链接1![可选](url) 图片超链接 上下标123456789101112直接写在内容中,只取``中间内容hexo中建议使用这种下标:`$a_2$` 上标:`$a^2$`html格式,需要转义下标：a&lt;sub&gt;2&lt;/sub&gt;上标：a&lt;sup&gt;2&lt;/sup&gt;Markdown自带,推荐下标 ：θ~1~ 上标 ：θ^2^ 表格1234567891011| 符号 | 功能 || :----: | :----------------: || * | 零次或多次 || + | 一次或多次 || ？ | 零次或一次 || ^ | 匹配字符串开头 || $ | 匹配字符串结尾 || \\s | 表示空格 || . | 匹配任意一个字符 || \\w | 匹配一个字符 || \\d | 匹配一个数字 | 数学公式123$$中间写公式$$ 四则运算123&#123;&#125; 复合标t_ &#123;a0&#125;\\frac&#123;分子&#125;&#123;分母&#125; 分式表达 Emoji表情123`:中间填入对应的字符:``:sneezing_face:`:sneezing_face: 🤧 或者使用win + .​调出emoji​表情 表情 代码 表情 代码 表情 代码 🤧 :sneezing_face:​ 🤶 :mrs_claus:​ 🍈 :melon:​ 😠 :angry:​ 🤓 :nerd_face:​ 🥝 :kiwi_fruit:​ 👼 :angle:​ 😣 :persevere:​ 🌶 :hot_pepper:​ 😧 :anguished:​ 👿 :imp:​ 🌭 :sneezing_face:​ 😲 :astonished:​ 🎃 :ack_o_lantern:​ 🍔 :hamburger:​ 🤢 :nauseated_face:​ 🍅 :tomato:​ 🍩 :doughnut:​ 🤠 :cowboy_hat_face:​ 🍊 :tangerin:​ 🥕 :carrot:​ 😵 :dizzy_face:​ 🍍 :pineapple:​ 🍌 :banana:​ 😁 :grin:​ 🍑 :peach:​ 🥑 :avocado:​ 😷 :mask:​ 🍋 :lemon:​ 💩 :poop:​ 🐴 :horse:​ 🎠 :carousel_horse:​ 🐼 :panda_face:​ 🐎 :racehorse:​ 🦄 :unicorn:​ 🐵 :sneezing_face:​ 🏇 :horse_racing:​ 🐷 :pig:​ 🐸 :frog:​ 🦊 :fox_face:​ 🐉 :dragon:​ 🤡 :clown_face:​ 🐶 :dog:​ 🐮 :COW:​ 🐔 :chicken:​ ‍","categories":[{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}],"author":"xuaner"},{"title":"芯动力——高质量Verilog设计","slug":"芯动力——高质量Verilog设计","date":"2022-12-03T13:06:07.000Z","updated":"2022-12-22T07:38:36.727Z","comments":true,"path":"2022/12/03/芯动力——高质量Verilog设计/","link":"","permalink":"http://example.com/2022/12/03/%E8%8A%AF%E5%8A%A8%E5%8A%9B%E2%80%94%E2%80%94%E9%AB%98%E8%B4%A8%E9%87%8FVerilog%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"高质量verilog设计可综合语句 always if-else case assign if语句if-else​语句映射为多路选择器 不同的if-else​结构会导致不同的电路结构，根据约束不同，设计：先加法器后选择器；先选择器后加法器 加法器的面积比选择器大，但是先加法器后选择器的延时小。 ​ 单独的if-else​语句没有优先级，会逐一检查，多个if​语句之间具有优先级，多个选择器之间级联，最后一级具有最高优先级。 ​ 若某些设计中，有些信号要求先到达（如关键使能信号、选择信号等），而有些信号需要后到达（如慢速信号、有效时间较长的信号等），此时侧需要使用if…if…结构。设计方法：最高优先级给最迟到达的关键信号 case语句case​和单if​语句类似，但是case​语句互斥 case​的使用注意点： 要在always​块里使用，如果是用always​块描述组合逻辑，注意括号里的敏感变量列表都是电平触发，并且赋值时都要用阻塞赋值“&#x3D;”： always​块里的变量必须声明成reg类型，当然声明成reg​类型不代表一定会综合成寄存器，只是语法要求always​块里要这样； always​：块描述组合逻辑时，用*​可以代表所有always​块内敏感信号； 分支条件要写全，最好补齐default​缺省条件，不然在组合逻辑中可能会由于条件不全导致出现锁存器Latch​； Latch语句综合工具很难解释Latch​ latch​由电平触发，非同步控制。在使能信号有效时latch​相当于通路，在使能信号无效时latch​保持输出状态。DFF​由时钟沿触发同步制。 latch​容易产生毛刺，DFF​则不易产生毛刺。 latch​将静态时序分析变得极为复杂。 Latch​容易在不完备的if-else​和case​中产生 使用完备if-else​语句 使用default​覆盖case​语句 查看综合工具的warning​信息 使用full_case​，告诉综合工具case​已经完备 ​ 使用parallel_case​，告诉综合工具，所有条件互斥且并行，没有优先权 ​ 资源重复利用负载均衡、逻辑复制 资源共享、减小面积 ​ 顺序重排、降低延时 ​ 赋值语句关于assign​： 仅用于信号连接 难以阅读，且多层嵌套后很难被综合器解释 可综合风格always​敏感信号表 所有的组合逻辑或锁存的always​结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号。 综合过程将产生一个取决于除敏感列表中所有其它值的结构，它将可能在行为仿真和门级仿真间产生潜在的失配。 在综合过程中，每个Verilog always​敏感信号列表只能对应一个时钟。 这是将每一个过程限制在单一寄存器类型的要求。 wait​和delay​不能用于可综合RTL​设计 原因：从RTL​级转换到gate​级的综合工具一般都不支持Wait​声明和#delay​声明，为了有效的综合，这些语句应该避免。 例外：在不需要行综合的行为模块中，如测试模块Testbench​、表示行为的虚拟器件模块中可以使用。 非阻塞赋值和阻塞赋值 在时序电路中必须使用非阻塞赋值&lt;=​ 组合逻辑电路必须使用阻塞赋值=​ 异步逻辑和同步逻辑 建议分开异步逻辑与同步逻辑 避免综合时的问题，简化约束和编码难度。 不可应用于非综合模块中（例如：总线模块，总线监视器或是模拟模块）除非他们被设计来综合仿真。 控制逻辑和存储器 建议控制逻辑和存储器逻辑分成独立的模块 便于高层的存储器模块的使用和便于重新描述为不同的存储器类型 优秀的设计 牢记并理解可综合“四大法宝”所对应的硬件结构 写前确认电路指标是什么：性能？面积？ 硬件思维方式，代码不再是一行行的代码而是一块一块的硬件模块 对所需实现的硬件电路“胸有成竹”，有足够的数电基础 降低延时尽可能将延时高的模块放在后面 RTL编码面积减小设计面积： 成本降低、功耗降低 特别是对于FPGA​的设计，直接决着FPGA​的选型 估计设计使用资源的数量，知道设计中哪些部分占用了较大的面积 触发器的数量有功能决定，很难减少，面积则很好估计 组合逻辑—》RTL​代码—》各种操作符 必须使用复杂运算符，需要考虑能否使用资源共享。 多比特操作，应该看一看这个信号的所有比特是否都需要参与操作，如果不是则可以只对需要的部分比特进行操作。 ​ addr&lt;=addr+32;​—》addr[7:5]&lt;=addr[7:5]+1;​ addr[4:0]&lt;=addr[4:0]+0;​ RTL编码功耗$$p_d&#x3D;∑afCV^2$$ pd是电路割点功耗总和，a是该点电路翻转次数，f是电路工作频率，C是该点电容，V表示电压值 RTL​无法改变负载电容、工作电压，只能考虑尽可能降低电路翻转频率 主要措施： 门控时钟 增加使能信号，使得部分电路只有在需要工作时才工作； 对芯片各个模块进行控制，在需要工作时才工作； 除了有用信号和时钟的翻转会消耗功耗组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。 ‍ RTL编码布线 但即使使用最好的布局工具，还是可能出现无法布通的情况。 如果可以在RTL​编码阶段考虑代码可能对布线产生的影响就可能避免最后出现无法布通的情况 RTL设计指导原则指导原则： 面积与速度互换 乒乓操作 流水线设计","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}],"author":"xuaner"},{"title":"Pandas技巧","slug":"Pandas技巧","date":"2022-12-01T11:21:58.000Z","updated":"2022-12-01T11:39:01.061Z","comments":true,"path":"2022/12/01/Pandas技巧/","link":"","permalink":"http://example.com/2022/12/01/Pandas%E6%8A%80%E5%B7%A7/","excerpt":"","text":"差集12#取df_data1和df_data2的差集，剩下df_data1的余差df_data3=pd.concat([df_data1,df_data2,df_data2]).drop_duplicates(keep=False) 掩膜12345#取a列和b列相等的行df_data2=df_data1[df_data1[&#x27;a&#x27;]==df_data1[&#x27;b&#x27;]]#取a列不为null的行df_data2=df_data1[df_data1[&#x27;a&#x27;].notna()] 替换值12#将a列的元素为 （null） 替换为空df_data1.loc[:,&#x27;a&#x27;]=df_data1.loc[:,&#x27;a&#x27;].replace(&#x27;(null)&#x27;,np.nan)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"http://example.com/tags/pandas/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"xuaner"},{"title":"TCL入门","slug":"TCL语法快速上手","date":"2022-11-27T14:35:27.000Z","updated":"2022-12-03T12:04:08.701Z","comments":true,"path":"2022/11/27/TCL语法快速上手/","link":"","permalink":"http://example.com/2022/11/27/TCL%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"变量123456789101112131415161718#置换变量set a &#x27;snow&#x27;puts $a #打印a的值#命令置换#[]内部是一个独立tcl语句set a [expr 3+4]puts $a#结果为7#转义字符puts &#x27;a\\tb&#x27;puts &#x27;a\\nb&#x27;#添加后缀puts $&#123;a&#125;_1#打印7_1 符号123456789#置换set x 1set Y 2puts &quot;\\t[expr $x + $Y]&quot;#打印3,&quot;&quot;中会置换命令和变量puts &#123;\\t[expr $x + $Y]&#125;#打印\\t[expr $x + $Y],&#123;&#125;中的内容当做普通字符 数组1234567891011#定义set cell_1(a_name) &quot;array_1&quot;set cell_1(b_name) &quot;array_2&quot;set cell_1(c_name) &quot;array_3&quot;#取值puts $cell_1(a_name)array size cell_1#打印 3,数组长度为3array names cell_1#打印a_name,b_name,c_name 列表1234567891011121314151617181920212223242526272829303132333435set ive_list&#123;liv1,liv2,liv3&#125;puts $ive_list#合并列表set list1&#123;l1,l2,l3&#125;set list2&#123;s1,s2,s3&#125;concat $list1 $list2#查看长度llength $list1llength [concat $list1 $list1]#返回index的元素,下标从0开始lindex $list1 1#打印l2#得到list1&#123;a,b,c,d,e&#125;的最后一个元素set list1 &#123;a,b,c,d,e&#125;lindex $list1 [expr [llength list1] -1]#末尾追加新元素set list1 &#123;a,b,c&#125;lappend list1 d#排序,默认按照ASICC码排列set list1 &#123;c,d,e,a,b&#125;lsort $list1set list1 &#123;1.0,1.2,0.3,0.1,0&#125;lsort -real $list1#按照浮点数排列set list1 &#123;a,a,e,e,c,c,b,b,d&#125;lsort -unique $list1#排序并唯一化元素 运算表达式1234567#求运算表达式的值expr 1 + 2expr 1 * 2expr 5/2.0#打印浮点数,2.5expr 5/2#打印整数,2 ‍流程控制** 1234567891011121314151617181920212223242526272829303132333435363738#if elseset a 3set b 2if &#123;$a &gt; $b&#125; &#123;puts $a&#125; else &#123;puts $b&#125;#打印2#foreachset list1 &#123;1,2,3&#125;foreach i $list1&#123;puts $i&#125;#打印1,2,3#break,continueset list1 &#123;3,2,1&#125;foreach i $list1&#123;if &#123;$i==2&#125; &#123;break/continue&#125;puts $i&#125;#whileset i 3while &#123;$i&gt;0&#125; &#123;puts $iincr i-1; #等效于 set i [expr $i-1]&#125;#forfor &#123;set i 3&#125; &#123;$i&gt;0&#125; &#123;incr i-1&#125; &#123;puts $i&#125; proc函数1234567891011121314151617#过程函数procproc add &#123;a b&#125; &#123;set sum [expr $a + $b]return $sum&#125;add 3 4#打印7#过程中使用global引用全局变量set a 1proc sample &#123;x&#125; &#123;global aset a [expr $a + 1]return [expr $a + $x]&#125;sample 3#打印5 正则表达式 符号 功能 * 零次或多次 + 一次或多次 ？ 零次或一次 ^ 匹配字符串开头 $ 匹配字符串结尾 \\s 表示空格 . 匹配任意一个字符 \\w 匹配一个字符 \\d 匹配一个数字 文本处理1234567891011121314#open,gets,close#只读模式#第一行开始逐行读取#关闭文件set inputFiles [open file.text r]while &#123;[gets $inputFiles line] &gt;=0&#125; &#123;puts &quot;$line&quot;&#125;close $inputsFiles#写入模式set outputFiles [open file.text w]puts $outputFiles &quot;hello world&quot;close $outputFiles 文本file.txt,读取内容求所有Slack的值之和 Slack &#x3D; -0.0051 Slack &#x3D; -0.0021 Slack &#x3D; -0.0012 12345678910set num 0set $inputFiles [open file.txt r]while &#123;[gets $inputFiles line] &gt;=0&#125; &#123;if &#123;[regexp &#123;^Slack\\s+=\\s+(-?\\d+.?\\d+)&#125;$line total slack]&#125; &#123;set num [expr $sum + $slack]&#125;&#125;close $inputFilesputs $sum ‍Synopsys TCL1234567891011121314151617181920#查看design中的portget_ports portsName#通配符查看get_ports *#查看以C开头的portget_ports C*#查看design中对应的cell的instanceget_cells cellsName#查看design中对应的netget_nets netsName#查看nets的个数llength [get_object_name[get_nets *]]#或者sizeof_collection[get_nets *]#查看pins,以Z开头get_pins */Z","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"TCL","slug":"TCL","permalink":"http://example.com/tags/TCL/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"FIFO","slug":"FIFO","date":"2022-11-27T12:39:03.000Z","updated":"2022-12-23T05:58:18.599Z","comments":true,"path":"2022/11/27/FIFO/","link":"","permalink":"http://example.com/2022/11/27/FIFO/","excerpt":"","text":"FIFOFIFO（First In First Out）是一种数据缓冲器 异步FIFO同步FIFO可以看做异步FIFO的一个特例 异步FIFO可以分为 写时钟域地址管理 读时钟域地址管理 读时钟域读地址到写时钟域的格雷码同步 写时钟域写地址到读时钟域的格雷码同步 写时钟域的满和将满信号的产生 读时钟域的空和将空信号的产生 格雷码 避免采样时钟问题 引入格雷码，格雷码相邻地址只有1bit​跳变 格雷码的原理:从右往左，每2位异或 0000​-&gt;0000​ 0010​​-&gt;0011​​ 123456789101112131415161718192021222324//以FIFO深度16,格雷码编解码情况核心代码//编码always@(posedge clka or posedge reset) if(reset) b&lt;=4&#x27;b00; else b&lt;=a^(a&gt;&gt;1);//异步采样always@(posedge clka or posedge reset) if(reset) c&lt;=4&#x27;b00; else c&lt;=b;//解码always@(posedge clka or posedge reset) if(reset) d&lt;=4&#x27;b00; else begin d[3]=c[3]; d[2]=c[3]^c[2]; d[1]=c[2]^c[1]; d[0]=c[1]^c[0]; end 注意，先将clka​时钟的地址Gray​编码，然后用b​时钟采样Gray​编码地址并暂存，最后用b​时钟对暂存的Gray​编码地址进行译码。 省略b​时钟采样暂存的Gray​编&#x2F;解码是没有任何意义的。 格雷码的问题并不是一定要用格雷码做读写指针，而是当深度为2次幂的时候列好格雷码满足消除亚稳态的需求在非2次幂深度情况下，格雷码已经不再适用，此时的解决方法通常有 若深度为偶数，可采用最接近的2次幂的格雷码编码，在此基础上修改； 深度为一般数值时，可自行设计一种逻辑电路，或者查找表，以实现指针每次只跳变一次的功能； 以上方法通常在设计层面较为复杂，若无特定需求，可将FIFO深度设置为2次幂，浪费一些存储空间，来化简控制电路的复杂度。 FIFO深度吞吐量相同满足 (A&#x2F;B) * f1&#x3D;(Y&#x2F;X) * f2 深度计算公式 fifo_depth&#x3D;data_length-(data_length&#x2F;f1) * [(Y&#x2F;X) * f2] ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"FIFO","slug":"FIFO","permalink":"http://example.com/tags/FIFO/"}],"author":"xuaner"},{"title":"测试博客","slug":"测试","date":"2022-11-26T12:41:21.000Z","updated":"2023-07-13T02:42:48.741Z","comments":true,"path":"2022/11/26/测试/","link":"","permalink":"http://example.com/2022/11/26/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试volantis主题博客运行状态","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试区","slug":"测试区","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95%E5%8C%BA/"}],"author":"xuaner"},{"title":"数据结构与算法-02-线性表","slug":"数据结构与算法-02-线性表","date":"2022-09-07T08:04:07.000Z","updated":"2023-07-17T08:05:43.810Z","comments":true,"path":"2022/09/07/数据结构与算法-02-线性表/","link":"","permalink":"http://example.com/2022/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-02-%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"线性表线性表概念线性表(List):零个或者多个数据元素的有限序列线性表的长度应该小于等于数组长度，这样可以减少性能的损耗往线性表中插入数据的时候，插入位置后面的所有的数据都要往后挪动一位，同时要保证插入后的线性表长度要小于数组长度，插入的位置也要合理，不然会报错在删除数据的时候，删除位置后面的所有数据都要向前挪动一位，如果删除位置不合理，则报错 优点 缺点 无须为表示表中元素之间的逻辑关系而增加额外的储存空间 插入和删除操作需要移动大量元素 可以快速地存取表中任一位置的元素 当线性表长度变化比较大时，难以确定储存空间的容量 便于查找 造成储存空间的碎片 线性表结构123456#define MAXSIZE 20typedef int ElemType;typedef struct&#123; ElemType data[MAXSIZE]; int length; //线性表当前长度&#125;SqList; (1) 并集操作1234567891011121314151617void unionL(List *La,list Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len=ListLength(*La); Lb_len=ListLength(Lb); for(i=1;i&lt;=Lb_len;i++) &#123; GetElem(Lb,i,&amp;e); if(!LocateElem(*La,e)) &#123; ListInsert(La,++La_len,e); &#125; &#125;&#125; (2) 获取当前元素*Status*​是函数的类型，其值是函数结果状态代码，如​*OK*​等。初始条件：顺序线性表​*L*​已存在，​*1&lt;=i&lt;=listLength(L)*​操作结果：用​*e*​返回​*L*​中第​*i*​个数据元素的值。 12345678910111213141516#define OK 1#define ERROR 0#define TURE 1#define FALSE 0typedef int Status;Status GetElem(SqList L, int i, ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) &#123; return ERROR; &#125; *e = L.data[i-1]; return OK;&#125; (3) 插入元素初始条件：顺序线性表​*L*​已存在，​*1&lt;=i&lt;=listLength(L)*​操作结果：在​*L*​中第​*i*​个位置之前插入新的数据元素​*e*​，​*L*​长度​*+1* 1234567891011121314151617181920212223Status ListInsert(SqList *L, int i, ElemType e)&#123; int k; if(L-&gt;length == MAXSIZE) //线性表满了 &#123; return ERROR; &#125; if(i&lt;1 || i&gt;L-&gt;length+1) //i越界 &#123; return ERROR; &#125; if(i&lt;=L-&gt;length) //若插入位置不在表尾 &#123; //将要插入位置后数据元素向后移动一位 for(k=L-&gt;length-1;k&gt;i-1;k--) &#123; L-&gt;data[k+1]=L-&gt;data[k]; &#125; &#125; L-&gt;data[i-1]=e; //插入新元素 L-&gt;length++; return OK;&#125; (4) 删除元素初始条件：顺序线性表​*L*​已存在，​*1&lt;=i&lt;-ListLength(L)*​操作结果：删除​*L*​的第​*i*​个数据元素，并用返回其值，​*L*​的长度​*-1*​ 12345678910111213141516171819202122Status ListDelete(SqList *L, int i, ElemType *e)&#123; int k; if(L-&gt;length ==0) //链表为空 &#123; return ERROR; &#125; if(i&lt;1 || i&gt;L-&gt;length) //i越界 &#123; return ERROR; &#125; *e = L-&gt;data[i-1]; if(i&lt;L-&gt;length) //若删除位置不在表尾 &#123; for(k=i;k&lt;L-&gt;length;k++) &#123; L-&gt;data[k-1]=L-&gt;data[k]; &#125; &#125; L-&gt;length--; return OK;&#125; 插入和删除的时间复杂度。最好的情况：插入和删除操作刚好要求在最后一个位置操作，不需要移动任何元素，时间复杂度为O(1)​ 最坏的情况：要插入和删除的位置是第一个元素，意味着要移动所有的元素向后或者向前，时间复杂度为O(n)​ 平均情况：就取中间值O((n-1)/2)​，即O(n)​ 优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任意位置的元素 缺点： 插入和删除操作需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容 容易造成存储空间的“碎片” ‍","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表","slug":"线性表","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}],"author":"xuaner"},{"title":"数据结构与算法-01-时间复杂度","slug":"数据结构与算法-01-时间复杂度","date":"2022-09-03T07:07:34.000Z","updated":"2023-07-17T07:09:21.611Z","comments":true,"path":"2022/09/03/数据结构与算法-01-时间复杂度/","link":"","permalink":"http://example.com/2022/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-01-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"算法与数据结构推导大O阶方法推导大O阶： 1.用常数1取代运行时间中的所有加法常数 2.在修改后运行次数函数中，只保留最高阶项 3.如果最高阶项存在且不是1，则去除与这个项相乘的常数 (1) 常数阶时间复杂度为O(1) 123int sum=0,n=100;sum=(1+n)*n/2;printf(&quot;%d&quot;,sum); (2) 线性阶时间复杂度为O(n),因为循环体要执行n次 12345int i;for(i=0;i&lt;n;i++)&#123; //时间复杂度为O(1)&#125; (3) 对数阶时间复杂度为O(logn) 12345int count=1;while(count&lt;n)&#123; count=count*2; //时间复杂度为O(1)&#125; (4) 平方阶时间复杂度为O(n​^2^) 1234567int i,j;for(i=0;i&lt;n;i++)&#123; for(j=0;i&lt;n;j++)&#123; //时间复杂度为O(1) &#125;&#125;//如果修改为m则时间复杂度为O(m*n) (5) 常见的时间复杂度 执行次数函数 阶 非正式术语 12 O(1) 常数阶 2n+3 O(n) 线性阶 3n​^2^+2n+1 O(n​^2^) 平方阶 5log​2n+20 O(log​n) 对数阶 2n+3nlog​2n+19 *O(*​n*logn*) nlogn阶 6n​^3^+2n^2^+3n+4 O(n​^3^) 立方阶 2​^n^ O(2​^n^) 指数阶 时间复杂度从小到大: O(1)&lt;O(log​n)&lt;O(n)&lt;O(nlogn)&lt;O(n​^2^)&lt;O(n​^3^)&lt;O(2^n^)&lt;O(n!)&lt;O(n​^n^)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"xuaner"},{"title":"C语言基础","slug":"C语言基础","date":"2022-07-14T14:21:21.000Z","updated":"2023-07-17T06:38:30.211Z","comments":true,"path":"2022/07/14/C语言基础/","link":"","permalink":"http://example.com/2022/07/14/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"","text":"C语言基础补全基本数据类型 使用一个变量时定义int​、char​、float​、double​等类型，开辟不同空间大小的内存 单片机以stm32​为例子，一般最大使用int​，常见使用unsigned char​或者char​一字节空间作为基本的元 ‍ 数组 定义20个整型变量、15个字符类型变量、10个浮点变量类型，并赋值。 每组使用数组来定义int a[20];​ 单片机以stm32​为例，常见的字库使用数组来定义，以ASCII​码顺序编号 上面的定义了三类数据，每类数据分别需要3个怎么定义和赋值，则可采取数组嵌套即二维数组的方式来定义 int a[3][10];​​ ‍ 指针1234567891011121314151617181920int a[3]=&#123;3,4,5&#125;;int b=2;int* p=a;//打印均为 3 4 5printf(&quot;%d %d %d&quot;,a[0],a[1],a[2]);printf(&quot;%d %d %d&quot;,*a,*(a+1),*(a+2));printf(&quot;%d %d %d&quot;,p[0],p[1],p[2]);printf(&quot;%d %d %d&quot;,*p,*(p+1),*(p+2));//打印为4 5 [一长串数字]/* 数组a就是地址,是a[0]的首地址, (a+1)偏移到第二位a[1]的地址, 再取[index]则继续向后偏移index位取其地址位的内容 (a+2)偏移到a[2]的地址,再取index=2,数组越界*/printf(&quot;%d %d %d&quot;,(a+1)[0],(a+1)[1],(a+2)[2]);printf(&quot;%d %d %d&quot;,(p+1)[0],(p+1)[1],(p+2)[2]);p=&amp;b;//打印为2printf(&quot;%d&quot;,*p); 多维数组 定义一个数组int a[3][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;​ 12345678910111213graph TB A[1] B[2] C[3] D[4] E[5] F[6] G[7] H[8] I[9] J[10] K[11] L[12] 定义一个int a[3][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;​的三维数组 12345678910111213graph TB; A[1] B[2] C[3] D[4] E[5] F[6] G[7] H[8] I[9] J[10] H[11] L[12] 123456int* p;p=a[0];//打印1printf(&quot;%d&quot;,a[0][0]);printf(&quot;%d&quot;,p[0][0]);printf(&quot;%d&quot;,**p); 地址等效 a[0]​和*p​ *p+1​和a[0]+1​ *​可以视为降维手段，*p​将12​一组数据降低到a[0]​的一维中，相当于数据做了切分 类比数据int a[2][5][10];​对其进行取地址*(*(*(p+1)+2)+3)​中间2层*​是降维，先降低到a[1]​这一段，然后偏移2​，数据地址来到a[1][2]​，然后再偏移3​，降维到a[2][5][10]​这一段，最后*​取值得到a[1][2][3]​的值 ‍ 结构体两种定义方式 123456789101112struct student&#123; char id[10]; char name[10]; int num[20];&#125;;typedef struct student&#123; char id[10]; char name[10]; int num[20];&#125;stu; 结构体链表​ 123456789101112typedef struct Node&#123; int data; struct LNode* next;&#125;LNode,*Linklist;Lode s;Linklist p =&amp;s;//等效于typedef struct LNode LNode;typedef struct LNode* linklist;linklist=&amp;node; 结构体动态申请内存 1234567struct student&#123; char sno[20]; char name[20]; float score[3];&#125;;struct student* s=(struct student*)malloc(sizeof(struct student)); 此处使用​(struct student *)​​ 指针类型强制转换，避免结构体在栈上创建，让其在堆上动态创建 tips: 局部变量在栈上 动态分配在堆上 静态全局变量在数据段 结构体赋值 1234567891011121314151617181920212223typedef struct LNode&#123; int data; struct LNode* next;&#125;LNode,*Linklist;int main()&#123; //第一种结构体赋值方式 LNode p1; p1.data=1; p1.next=NULL; //第二种结构体赋值方式 LNode p2; Linklist q2; q2=&amp;p2; q2-&gt;data=2; q2-&gt;next=NULL; //第三种结构体赋值方式厂 Linklist q1=(Linklist)malloc(sizeof(LNode)); q1-&gt;data=2; q1-&gt;next=NULL;&#125; ‍ ‍","categories":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言基础","slug":"C语言基础","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"}],"author":"xuaner"},{"title":"Linux快速上手","slug":"Linux快速上手","date":"2021-10-17T09:34:15.000Z","updated":"2023-07-13T02:38:51.797Z","comments":true,"path":"2021/10/17/Linux快速上手/","link":"","permalink":"http://example.com/2021/10/17/Linux%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Linux快速上手计算机硬件—&gt;硬件接口层（内核、核心层kernel）—&gt;命令解释层（shell）—&gt;外围应用层 基本操作1234su root #切换到root用户su xuaner #切换到普通用户passwd root #修改root用户密码ifconfig #查看当前ip信息 文件系统目录为虚拟目录，由挂载点决定文件写入磁盘位置 Vim​ 基本命令123456789101112131415161718192021222324252627282930313233343536373839vim test.txt #打开文件 一般模式，只能进行删除、复制、粘贴yy #复制光标当前的一行yny #复制一段，从光标当前行到后n行,nyy也一样 y$ #复制当前光标行后所有字符y^ #复制当前光标行前所有字符yw #复制当前单词p #粘贴 npdd #删除 dnd #删除多行，ndddw #删除单词d$ #删除当前光标行后所有字符d^ #删除当前光标行前所有字符x #剪切X #回退，相当于backspace ，shift+x 等同于Xr #替换R #连续替换$ #快速移动到行尾^ #快速移动到行首b #快速移动到上一个词首w #快速移动到下一个词首e #快速移动到词尾gg #文档首ngg #跳转到n行G #文档尾:q #退出文件 命令模式，使用:或者/ ESC退出到一般模式:w #保存 将缓存区写入到磁盘:wq #保存退出:q! #强制退出:set nu #显示行号:set nonu #不显示行号/username #查询username:s/username/usernames #查找光标第一个username替换成usernames:s/username/usernames/g #查找光标所在行所有username替换成usernames:%s/username/usernames #查找光标所有行第一个username替换成usernames:%s/username/usernames/g #查找光标所有行所有username替换成usernamesn #向下查找N #向上查找i #插入 编辑模式， ESC退出到一般模式u #撤回 撤回到上次保存之前 网络配置123456789vim /etc/sysconfig/network-scripts/ifcfg-ens33#ip地址IPADDR=192.168.202.100#网关GATEWAY=192.168.202.2#域名解析器DNS1=192.168.202.2#显示onboot=yes 12#网络重启service network restart 可能遇到的配置问题 （1）物理机能ping通虚拟机，但是虚拟机ping不通物理机，一般都是因为物理机的防火墙问题，把防火墙关闭就行（2）虚拟机能ping通物理机，但是虚拟机ping不通外网，一般都是因为DNS的设置有问题（3）虚拟机ping www.baidu.com显示域名未知等信息，一般查看GATEWAY和DNS设置是否正确（4）如果以上全部设置完还是不行，需要关闭NetworkManager服务 systemctl stop NetworkManager关闭 systemctl disable NetworkManager禁用（5）如果检查发现systemctl status network有问题需要检查ifcfg-ens33 网卡启动异常，或者没有网络显示123456ifup ens33chkconfig NetworkManager offchkconfig network onsudo chkconfig network onservice NetworkManager stopservice network start 12345678910hostname #主机名vim /etc/hostname #修改完后需要重启hostnamectl set-hostname linux100 #修改主机名为linux100vim /etc/hosts #修改hosts文件，映射192.168.72.100为linux100192.168.72.100 linux100#通过ssh远程连接ssh root@linux100#退出exit 系统管理 计算机中，一个正在执行的程序或命令，被叫做，“进程”（process）。 启动之后一只存在、常驻内存的进程，一般被称作“服务”（service）。 守护进程 123ls /usr/bin/ #查看命令ls /usr/bin/ | grep service #筛选service相关的命令ls /usr/bin/systemd/system service服务管理 service 服务名 start | stop | restart |status ——-centos6 systemctl start | stop | restart |status 服务名 ——-centos7 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system CentOS7的运行级别简化为：multi--user.target等价于原运行级别3（多用户有网，无图形界面）~graphical.target等价于原运行级别5（多用户有网，有图形界面） 1234567891011121314#查看当前运行级别：systemctl get-defaultinit 3 #切换至命令界面 ctrl+alt+f2init 5 #切换至GUI界面 ctrl+alt+f1chkconfig --list #列出服务chkconfig network on #打开network服务chkconfig --level 3 network off #关闭network级别3systemctl status NetworkManager #查看服务systemctl disable NetworkManager #关闭net服务systemctl list-unit-files #查看所有服务systemctl status firewalld #查看防火墙状态 （1）sync（功能描述：将数据由内存同步到硬盘中）（2）halt（功能描述：停机，关闭系统，但不断电）（3）poweroff（功能描述：关机，断电）（3）reboot（功能描述：就是重启，等同于shutdown-r-now）（4）shutdown[选项]时间 -H 相当于 –halt 停机 -r -r&#x3D;reboot 重启 now 立刻关机 时间 等待多久后关机，单位分钟 常用命令1234567ls -l /bin/ | grep sh #把bin目录下带sh的按照一行一个输出man [命令或配置文件] #获得帮助type cd #判断cd是否是内嵌命令man -f cd #查看内置命令helphelp [命令] #只能看内置命令[命令] --help #命令提供了内置帮助 文件目录类12345678910111213141516171819202122232425262728293031323334353637pwd #打印工作目录pwd -P #显示软链接的实际路径cd - #回到上次的目录ls -a #显示所有文件，包括隐藏文件ls -l #显示文件详细信息ls -lh #人性化显示详细信息ll #显示详细信息-带有权限mkdir a #创建一个名为a的文件夹mkdir -p a/b/c/d #父目录不存在自动创建rmdir -p a/ #里面包含子目录，也一并删除touch 1.txt #创建一个空文件cp 1.txt /home/xuaner/ #复制1.txt到新的路径下cp 1.txt /home/xuaner/2 #复制1.txt到新的文件下，会覆盖内容，需要验证是否覆盖\\cp 1.txt /home/xuaner/2 #复制1.txt到新的文件下，会覆盖内容，无需验证-----使用的是原生命令alias #别名cp -r /a /home/xuaner/ #递归复制文件目录a下面所有文件到目录xuaner下rm 1.txt #删除文件rm -f 1.txt #强制删除rm -r a/ #递归删除rm -rf a/ #强制递归删除mv 1.txt /home/xuaner/ #移动文件mv 1.txt /home/xuaner/2.txt #移动文件并改名cat 1.txt #查看文件内容cat n 1.txt #显示行号more 1.txt #文件分屏查看less 1.txt #功能和more类似echo &quot;hello&quot; #输出内容到控制台echo -e &quot;hello \\n world&quot; #支持转义字符echo $ #查看环境变量，按tab head 1.txt #查看文件头十行head -n 20 1.txt #查看20行tail 1.txt #查看尾十行tail -n 20 1.txt #查看尾20行tail -f 1.txt #实时追踪该文档的所有更新ln -s [原文件或目录名] [软链接名] #软链接history #历史命令history -c #清空历史命令 输入输出重定向 基本语法（1）ls -1 &gt; 文件（功能描述：列表的内容写入文件a.tⅸt中（覆盖写））（2）ls -al &gt;&gt; 文件（功能描述：列表的内容追加到文件aa.tⅸt的末尾）~（3）cat 文件1 &gt; 文件2（功能描述：将文件1的内容覆盖到文件2）（4）echo “内容” &gt;&gt; 文件 时间日期类12345678910111213date #显示日期date +%Y #显示年date+%m #显示月date +%d #显示天date +%Y-%m-%d%H:%M:%Sdate -d&quot;1 day ago&quot; #显示前一天date -s &quot;2022-09-19 12:12:00&quot; #设置时间 ntpdate ntp1.aliyun.com #时间同步#修改时间为北京时间rm -rf /etc/localtimeln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtimecal #日历 用户管理 useradd 用户名（功能描述：添加新用户）useradd -g 组名 用户名（功能描述：添加新用户到某个组） 12345678passwd xuaner #给xuaner设置密码id xuaner #查看xuaner是否存在cat /etc/passwd #查看有哪些用户who am i #查看当前用户，最原始登录用户whoami #查看当前用户sudo ls #临时提升权限vim /etc/sudoers #添加用户权限userdel -r david #删除david用户 用户组管理1234usermod -g meifa tony #把tony用户加到meifa组usermod -g qym xuaner #xuaner用户加到qymgroupmod -n haircut meifa #修改meifa组名为haircutgroupdel tony #删除tony组 文件权限搜索查找1234567891011find -name info #查找文件名为info的文件find test/ -name info #查找test目录下的info文件find -name &quot;*.cfg&quot; #通配符查找find -size +2k #查找文件大于2k的updatedb #更新数据库locate tmp #快速查找包含tmp的所有文件which ls #查找ls命令在哪whereis locate #查找locate命令在哪grep -n boot 1.txt #查找boot在1.txt中出现的行号ls | grep .cfg #查找后缀为cfg的文件wc info #统计info出现的行 次数 字节大小 压缩解压命令123456789101112131415161718gzip 1.txt #压缩1.txt 为.gz后缀 只能压缩文件不能压缩目录，不保留原文件，每个压缩文件单独存放gunzip 1.gz #解压缩zip 1.zip 1.txt 2.txt #压缩，可以压缩文件和目录，递归压缩，保留原文件，压缩文件可存为一个unzip 1.zip #解压zip -r xuaner.zip /home/xuaner #压缩xuaner目录下所有文件unzip -d /tmp xuaner.zip #解压文件到tmp目录下tar [选项] 1.tar.gz #归档打包-c #打包.tar-v #显示详细信息-f #指定压缩后包名-z #打包同时压缩-X #解包.tar文件-C #解压到指定目录tar -zcvf 1.tar.gz 1.txt 2.txt info #打包多个文件，压缩为1.tar.gztar -zxvf 1.tar.gz -C /tmp #解压包到tmp文件目录 磁盘操作yum install tree du [目录/文件]（功能描述：显示目录下每个子目录的磁盘使用情况） 12345678910111213du [选项] [目录/文件]-h #按照GB、MB等显示-a #不仅查看子目录大小，还包括文件-c #显示所有文件和子目录大小，显示总和-s #只显示总和--max-depth=n #指定子目录深层ndu --max-depth=1 -ah #只显示当前目录下面一级df -h #查看磁盘占用信息lsblk -h #查看详细设备的挂载情况，显示文件系统信息ls /dev/ | grep sr0 #管道查看sr0ll /dev/ | grep sr0 #管道查看sr0详细情况 挂载操作123456789101112131415161718192021222324mount [-t vfstype] [-o options] device dir #挂载设备-t vfstype #指定文件系统的类型，通常不必指定。mout会自动选择正确的类型 #常用类型有： #光盘或光盘镜像：iso9660 #D0Sfat16文件系统：msdos #Windows9xfat32文件系统：vfat #Windows NT ntfs文件系统：ntfs #Mount Windows文件网络共享：smbfs #UNIX（LINUX）文件网络共享：nfs -o options #主要用来描述设备或档案的挂接方式。常用的参数有： #loop：用来把一个文件当成硬盘分区挂接上系统 #ro：采用只读方式挂接设备device #要挂接的设备dir #设备在系统上的挂接点（mount point）mount /dev/cdrom /mnt/cdrom #把光盘驱动挂载到/mnt/cdrom下umount [设备文件名或者挂载点] #卸载设备umount /dev/cdrom #卸载挂载点#设置开机自动挂载vim /etc/fstab/dev/cdrom /mnt/cdrom iso9660 defaults 0 0 分区操作12345fdisk -l #查看磁盘分区详情fdisk [硬盘设备名] #对新增硬盘进行分区操作fdisk /dev/sdb #对sdb硬盘进行操作mkfs -t xfs /dev/sdb1 #对sdb1进行格式化mount /dev/sdb1 /home/cd1 #把sdb1 挂载在/home/cd1目录下 进程管理查看系统进程123456789ps [选项] | grep XXXa #列出带有终端的所有用户的进程x #列出当前用户的所有进程，包括没有终端的进程u #面向用户友好的显示风格-e #列出所有进程-u #列出某个用户关联的所有进程-f #显示完整格式的进程列表ps aux | grep XXX #查看系统所有进程ps -ef | grep XXX #查看子父进程之间的关系 终止进程1234kill [选项] pid #通过进程号杀死进程killall 进程名称 #通过进程名杀死进程-9 #表示强迫进程立即停止kill -l #信号值 进程树123pstree [选项]-p #显示PID-u #显示进程的所属用户 实时监控进程1234top [选项]-d 秒数 #指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令-i #使top不显示任何闲置或者僵死进程。-p #通过指定监控进程ID来仅仅监控某个进程的状态。 网络端口123456netstat -anp | grep 进程号 #查看该进程网络信息netstat -nlp | grep 端口号 #查看网络端口号进程占用情况-a #显示所有正在监听（listen）和未监听的套接字（socket）-n #拒绝显示别名，能显示数字的全部转化成数字-l #仅列出在监听的服务状态-p #表示显示哪个进程在调用进程 系统定时任务1234crontab [选项]-e #编辑crontab定时任务-l #查询crontab任务-r #删除当前用户所有的crontab任务 第一个*一小时当中的第几分钟 0-59第二个*一天当中的第几小时 0-23第三个*一个月当中的第几天 1-31第四个*一年当中的第几月 1-12第五个*一周当中的星期几 0-7(0和7都代表星期日) 软件包管理RPM123456789101112rpm -qa #查询所安装的所有pm软件包rpm -qa | grep firefox #过滤rpm -qi firefox #查询某一个的详细信息rpm -e firefox #卸载软件包rpm -e --nodeps firefox #卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。#安装rpm [选项] 包全名-i #install，安装-v #--verbose，显示详细信息-h #--hash，进度条--nodeps #安装前不检查依赖 YUMYUM（全称为Yellow，dog Updater，Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 1234567891011yum [选项][参数]#选项-y #对所有的都执行yes#参数install #安装rpm软件包update #更新rpm软件包check-update #检查是否有可用的更新rpm软件包remove #删除指定的rpm软件包list #显示软件包信息clean #清理yum过期的缓存deplist #显示yum软件包的所有依赖关系 修改网络源123456789101112131415#修改/etc/yum.repos.d/CentOS-Base.repoyum install wget#备份原源cp CentOS-Base.repo CentOS-Base.repo.backup#下载镜像wget http://mirrors.aliyun.com/repo/Centos-7.repo #阿里云wget http://mirrors.163.com/.help/Centos7-Base-163.repo #网易#修改下载好的repos文件mv Centos7-Base-163.repo CentOS-Base.repo#清理旧缓存，缓存新数据yum clean allyum makecache#测试源yum list | grep firefoxyum -y install firefox ShellShell是一个命令行解释器，它接收应用程序用户命令，然后调用操作系统内核。 12#查看shell解释器cat /etc/shells 脚本脚本以#!bin/bash开头（指定解析器） 12345678910111213141516171819202122232425#脚本常见执行方式#第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）sh ./helloworld.shsh /home/xuaner/shells/helloworld.sh#bash+脚本的相对路径bash ./helloworld.shbash /home/xuaner/shells/helloworld.sh#第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）#(1)首先要赋予helloworld.sh脚本的+x权限chmod +x helloworld.sh#(2)执行脚本./helloworld.sh#注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。#第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。#【了解】第三种：在脚本的路径前加上“.”或者source. helloworld.shsource /root/helloworld.sh#原因：#前两种方式都是在当前shell中打开一个子shell来执行脚本内容，当脚本内容结束，则子shell关闭，回到父shell中。#第三种，也就是使用在脚本路径前加“.”或者source的方式，可以使脚本内容在当前shell里执行，#而无需打开子shell,这也是为什么我们每次要修改完/etc/profile文件以后，需要source一下的原因。#开子shell与不开子shell的区别就在于，环境变量的继承关系，如在子shell中设置的当前变量，父shell是不可见的。 变量常用系统变量$HOME、$PWD、$SHELL、$USER等 自定义变量12345678910111213141516171819#查看系统变量echo $HOME#显示当前shell中所有的变量set#查看所有的全局变量envprintenv#查看某个printenv HOME#子shell更改不会影响父shellmy_var=hello #赋值echo $my_varmy_var=&quot;hello,world&quot;export my_var #提升为全局变量unset my_var #撤销变量#只读变量readonly b=10 特殊变量$n 1$n（功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如$&#123;10&#125;） $# 1$#（功能描述：获取所有输入参数个数，常用于循环，判断参数的个数是否正确以及加强脚本的健壮性） $*、$@ 1234$*（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）$@（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待） $? 1$？（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行：如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。） 运算符12345678910$((1+2))$[1+2]expr 1 + 2expr 5 \\* 2echo $((5*2))echo $[5*2]#命令替换a=$(expr 5 \\* 2)echo $a 条件判断12345678910111213141516171819202122#(1)基本语法test conditione[condition] #（注意condition前后要有空格）#注意：条件非空即为rue，[xuaner]返回true，[]返回false。#(2)常用判断条件#（1）两个整数之间比较eq #等于（equal）-ne #不等于（not equal）-lt #小于（less than）-le #小于等于（less equal）-gt #大于（greater than）-ge #大于等于（greater equal）#注：如果是字符串之间的比较，用等号“=”判断相等：用“！=”判断不等。#(2)按照文件权限进行判断-r #有读的权限（read）-w #有写的权限（write）-x #有执行的权限（execute）#（3）按照文件类型进行判断-e #文件存在（existence）-f #文件存在并且是一个常规的文件（file）-d #文件存在并且是一个目录（directory） 12345a=hellotest $a = helloecho $?[ $a = hello]echo $? 12345#多条件判断（&amp;&amp;表示前一条命令执行成功时，才执行后一条命令，Ⅱ表示上一条命令执行失败后，才执行下一条命令）[ xuaner ] &amp;&amp; echo ok || echo notoka=15[ $a -lt 20 ] &amp;&amp; echo &quot;$a &lt; 20&quot; || echo &quot;$a &gt; 20&quot; 流程控制if判断12345678910111213141516if [条件判断];then 程序fiif [条件判断]then 程序fiif [条件判断]then 程序elif [条件判断]then 程序fi case12345678910111213141516case $变量名 in&quot;值1&quot;） 如果变量的值等于值1，则执行程序1;;&quot;值2&quot;） 如果变量的值等于值2，则执行程序2;;省略其他分支*）如果变量的值都不是以上的值，则执行此程序;;esac#case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。#双分号“；”表示命令序列结束，相当于java中的break。#最后的“*）”表示默认模式，相当于java中的default。 for循环123456789for ((初始值;循环控制条件;变量变化))do 程序donefor 变量 in 值1 值2 值3do 程序done while循环1234while [条件判断]do 程序done 12let a++ #shell高级内置实现a=$[$a+1] #原生 read读取控制台输入123456789read [选项] [参数]#选项-p #指定读取值时的提示符-t #指定读取值时等待的时闻（秒）加果-t不加表示一直等待#参数变量：指定读取值的变量名read -t 10 -p &quot;请输入&quot; nameecho $name 函数系统函数123456789101112131415basename [string/pathname] [suffix]#（功能描述：basename命令会删掉所有的前缀包括最后一个（）字符，然后将字符串显示出来。basename #可以理解为取路径里的文件名称#选项：#suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。filename=&quot;$1&quot;_log_$(data +%s)echo $filenamedirname [文件绝对路径]#（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））#dirname可以理解为取文件路径的绝对路径名称 自定义函数1234567891011121314151617181920212223242526272829[function] funname[()]&#123; Action; [return int;]&#125;#必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。#函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n（0-255）function add()&#123; s=$[$1+$2] echo &quot;和：&quot;$s&#125;read -p &quot;第一个&quot; aread -p &quot;第二个&quot; badd $a $b#完美版function add()&#123; s=$[$1+$2] echo $s&#125;read -p &quot;第一个&quot; aread -p &quot;第二个&quot; bsum=$(add $a $b)echo $sum 正则表达式12345^a #以a开头a$ #以a结尾. #匹配一个任意的字符* #表示0次或者多次[a-z] #字符区间，匹配一个字符 文本处理工具cut1234cut [选项] filename-f #列号，提取第几列-d #分隔符，按照指定分隔符分割列，默认是制表符“\\t”-c #按字符进行切割 后加加n表示取第几列比如-c l awk123awk [选项] 正则表达式-F #指定输入文件分隔符-v #赋值一个用户定义变量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"author":"xuaner"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"单片机外设","slug":"单片机外设","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA%E5%A4%96%E8%AE%BE/"},{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数字IC/数电","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E6%95%B0%E7%94%B5/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"},{"name":"常见器件","slug":"数字IC/常见器件","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"},{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"OLED","slug":"OLED","permalink":"http://example.com/tags/OLED/"},{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"},{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数电","permalink":"http://example.com/tags/%E6%95%B0%E7%94%B5/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"常见器件","slug":"常见器件","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"},{"name":"时序","slug":"时序","permalink":"http://example.com/tags/%E6%97%B6%E5%BA%8F/"},{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"pandas","slug":"pandas","permalink":"http://example.com/tags/pandas/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TCL","slug":"TCL","permalink":"http://example.com/tags/TCL/"},{"name":"FIFO","slug":"FIFO","permalink":"http://example.com/tags/FIFO/"},{"name":"测试区","slug":"测试区","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95%E5%8C%BA/"},{"name":"线性表","slug":"线性表","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"C语言基础","slug":"C语言基础","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]}