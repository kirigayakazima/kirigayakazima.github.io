{"meta":{"title":"我的博客","subtitle":"","description":"个人博客、kirigayakazima","author":"xuaner","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-11-26T11:21:45.716Z","updated":"2022-11-26T11:21:45.716Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-11-26T14:02:29.242Z","updated":"2022-11-26T14:02:29.242Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欢迎你"},{"title":"所有分类","date":"2022-11-26T11:23:35.091Z","updated":"2022-11-26T11:23:35.091Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-11-26T13:14:18.757Z","updated":"2022-11-26T13:14:18.757Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"xuaner"},{"title":"所有标签","date":"2022-11-26T11:25:18.529Z","updated":"2022-11-26T11:25:18.529Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"FreeRTOS-01-移植","slug":"FreeRTOS-01-移植","date":"2023-06-29T06:52:44.000Z","updated":"2023-06-29T06:57:32.061Z","comments":true,"path":"2023/06/29/FreeRTOS-01-移植/","link":"","permalink":"http://example.com/2023/06/29/FreeRTOS-01-%E7%A7%BB%E6%A4%8D/","excerpt":"","text":"堆和栈堆栈返回地址保存在栈中 添加串口打印功能 去掉无关代码、LCD等 增加串口打印功能 初始化串口 实现fputc 标准库移植将官方标准库移植到STM32F103C8T6 常见变量类型TaskHandle_t​是任务句柄类型，指针类型，原型为void *​ StackType_t​是任务堆栈类型，整型类型，原型为uint32_t​ StackTask_t​是任务块类型，结构体，原型为xSTATIC_TCB​结构体 移植注意事项FreeRTOSConfig.h配置中断服务 123456/**************************************************************** FreeRTOS与中断服务函数有关的配置选项,映射端口 ****************************************************************/#define xPortPendSVHandler PendSV_Handler#define vPortSVCHandler SVC_Handler Serial.c注意串口波特率一致性 尽量使用printf​而不使用自定义Serial_Printf​ main.c注意开启vTaskStartScheduler​ 创建任务静态SARM内存需要开启静态内存 12//支持静态内存#define configSUPPORT_STATIC_ALLOCATION 1 静态内存任务开启区函数 1234567LEDTask_Handle = xTaskCreateStatic((TaskFunction_t)LED_Task, //任务LED (const char*)&quot;LED_Task&quot;, //任务名 (uint32_t)128, //堆栈大小 (void*)NULL, //传给函数的参数 (UBaseType_t)4, //任务优先级 (StackType_t *)LED_Task_Stack, //任务堆栈 (StaticTask_t *)&amp;LED_Task_TCB); //任务控制块 动态SARM内存不开启静态内存 动态内存任务开启函数 123456xReturn = xTaskCreate((TaskFunction_t)LED_Task, //任务LED (const char*)&quot;LED_Task&quot;, //任务名 (uint16_t)512, //堆栈大小 (void*)NULL, //传给函数的参数 (UBaseType_t)2, //任务优先级 (TaskHandle_t *)&amp;LEDTask_Handle);//任务控制块指针 注意动态和静态的开启函数区别，参数不同，参数类型也不同。 多任务多任务相较于单任务，区别只在任务开启的个数，对应参数填好，开启任务即可实现多任务。 ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"}],"author":"xuaner"},{"title":"C52-day05","slug":"C52-day05","date":"2023-05-23T11:58:56.000Z","updated":"2023-05-23T11:59:34.006Z","comments":true,"path":"2023/05/23/C52-day05/","link":"","permalink":"http://example.com/2023/05/23/C52-day05/","excerpt":"","text":"高级定时器应用PWM调制LED灯并驱动电机代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/*time:2023-05-23PWM LED DC*/#include &lt;reg52.h&gt;#include &quot;Delay.h&quot;sbit LED=P1^0;sbit st = P3^0;sbit eoc = P3^1;sbit oe = P3^2;sbit RS = P3^3;sbit RW = P3^4;sbit E = P3^5;unsigned int vol = 0;unsigned char t[] = &#123;&quot;012346789&quot;&#125;;unsigned char str[] = &#123;&quot;VOLTAGE: &quot;&#125;;unsigned char i;unsigned char PWM_COUNT; //计数unsigned int HUXI_COUNT; //占空比更新时间unsigned char PWM_VLAUE; //占空比比对值bit direc_flag; //占空比更新方向// 写数据void writedate(unsigned int date)&#123; RS = 1; RW = 0; E = 0; P2 = date; Delay(5); E = 1; E = 0;&#125;// 写命令void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P2 = com; Delay(5); // 延时根据实际效果判断 E = 1; E = 0;&#125;// 初始化void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void timer0_init()&#123; TMOD=0x02; //模式设置，00100000，定时器0，工作于模式2（M1=1，M0=0）//定时器溢出值设置，每隔50ms发起一次中断。 TH0=(65536-50000)/256; TL0=(65536-50000)%256; TR0=1; //定时器0开始计时 ET0=1; //开定时器0中断 EA=1; //开总中断 PWM_COUNT =0;&#125;void time0() interrupt 1&#123; PWM_COUNT++; HUXI_COUNT++; if(PWM_COUNT == PWM_VLAUE) //判断是否到了点亮LED的时候 LED = 1; //点亮LED if(PWM_COUNT == 40) //当前周期结束 &#123; LED = 0; //熄灭LED PWM_COUNT = 0; //重新计时 &#125; if((HUXI_COUNT == 200) &amp;&amp; (direc_flag == 0)) &#123; //占空比增加10% HUXI_COUNT = 0; PWM_VLAUE++; if(PWM_VLAUE == 39) //占空比更改方向 direc_flag = 1; &#125; if((HUXI_COUNT == 200) &amp;&amp; (direc_flag == 1)) &#123; //占空比减少10% HUXI_COUNT = 0; PWM_VLAUE--; if(PWM_VLAUE == 1) //占空比更改方向 direc_flag = 0; &#125;&#125;void adc()&#123; // 开启START st = 0; st = 1; Delay(5); st = 0; while (eoc != 1); oe = 1; vol = P0; oe = 0; &#125; void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0; int i = 0; vol = vol * 100 / 51; temp0 = vol/100; temp1 = (vol%100)/10; temp2 = vol%10; writecom(0x80); Delay(5); for(i=0; i&lt;8; i++) &#123; writedate(str[i]); Delay(5); &#125; writecom(0x80 + 0x40 + 4); Delay(5); writedate(t[temp0]); Delay(5); writedate(&#x27;.&#x27;); Delay(5); writedate(t[temp1]); Delay(5); writedate(t[temp2]); Delay(5); writedate(&#x27;V&#x27;); Delay(5); &#125;void main()&#123; HUXI_COUNT = 0; PWM_COUNT = 0; PWM_VLAUE = 20; direc_flag = 0; LED = 1; //默认LED熄灭 timer0_init(); //定时器0初始化 initlcd(); while(1)&#123;// Delay(100);// LED=~LED; adc(); display(); &#125;&#125;//Delay.c#include &lt;intrins.h&gt;#include &lt;reg52.h&gt;#include &quot;Delay.h&quot;// 延迟1msvoid Delay(unsigned int n)&#123;//@11.0592MHz unsigned char i, j;//for(j=n;j&gt;0;j--)//for(i=112;i&gt;0;i--); while(n--) &#123; i = 2; j = 239; do &#123; while (--j); &#125; while (--i); &#125;&#125;//Delay.h#ifndef __Delay_H__#define __Delay_H__void Delay(unsigned int times);#endif ​ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day04","slug":"C52-day04","date":"2023-05-16T10:52:48.000Z","updated":"2023-05-16T10:53:18.567Z","comments":true,"path":"2023/05/16/C52-day04/","link":"","permalink":"http://example.com/2023/05/16/C52-day04/","excerpt":"","text":"AD转换‍ 代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/*time:2024-05-16数字电压表*/# include &quot;reg51.h&quot;sbit st = P3^0;sbit eoc = P3^1;sbit oe = P3^2;sbit RS = P3^3;sbit RW = P3^4;sbit E = P3^5;unsigned int vol = 0;unsigned char t[] = &#123;&quot;012346789&quot;&#125;;unsigned char str[] = &#123;&quot;VOLTAGE: &quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;// 写数据void writedate(unsigned int date)&#123; RS = 1; RW = 0; E = 0; P1 = date; delay(5); E = 1; E = 0;&#125;// 写命令void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P1 = com; delay(5); // 延时根据实际效果判断 E = 1; E = 0;&#125;// 初始化void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void adc()&#123; // 开启START st = 0; st = 1; delay(5); st = 0; while (eoc != 1); oe = 1; vol = P2; oe = 0; &#125; void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0; int i = 0; vol = vol * 100 / 51; temp0 = vol/100; temp1 = (vol%100)/10; temp2 = vol%10; writecom(0x80); delay(5); for(i=0; i&lt;8; i++) &#123; writedate(str[i]); delay(5); &#125; writecom(0x80 + 0x40 + 4); delay(5); writedate(t[temp0]); delay(5); writedate(&#x27;.&#x27;); delay(5); writedate(t[temp1]); delay(5); writedate(t[temp2]); delay(5); writedate(&#x27;V&#x27;); delay(5); &#125;void main()&#123; initlcd(); while(1) &#123; adc(); display(); &#125;&#125; ​ 直流电机 直流电机的控制： 方向控制：直流电机只有正负极，只需交换正负极就可以调节正反转。 转速控制：负载变化不大的时候，加在直流电动机两端的电压大小与其速度近似成正比。 PWM技术： 电动机的电枢绕组两端的电压平均值U为：$D &#x3D; \\frac{t_1}{T}U&#x3D;DU_s$ D为PWM的占空比：$D &#x3D; \\frac{t_1}{T}$ 占空比：一个周期之内高电平的时间与整个周期时长之比。范围：0~1 L293D 芯片： 顺时针转动：最大转速192 代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*time:2023-05-1651单片机对直流电机的控制*/# include &quot;reg51.h&quot;typedef unsigned int uint;sbit IN0 = P2^0;sbit IN1 = P2^1;sbit E = P2^2;void motor()&#123; IN0 = 1; IN1 = 0; E = 1;&#125;void inittimer()&#123; TMOD = 0X01; TH0 = (65536 - 10000)/256; TL0 = (65536 - 10000)%256; ET0 = 1; EA = 1; TR0 = 1; IN1 = 0;&#125;/*void timer_isr() interrupt 1&#123; TH0 = (65536 - 10000)/256; TL0 = (65536 - 10000)%256; // 占空比：%50 IN1 = ~IN1;&#125;*/void main()&#123; inittimer(); while(1) &#123; motor(); &#125;&#125; ​ 步进电机 驱动芯片：L298 四相步进电机四步法和八步法：四步法：给ABCD引脚给控制信号：1001、1100、0110、0011步进电机顺时针转动。八步法：四步法的一半，1001、1000、1100、0100、0110、0010、0011、0001 四步法转动角度大，更平滑。八步法转读角度小，但是能够实现更高的转速 代码​ 123456789101112131415161718192021222324252627282930313233343536373839/*time:2023-05-16步进电机*/# include &quot;reg51.h&quot;typedef unsigned char uchar;typedef unsigned int uint;uchar st[] = &#123;0x09,0x08,0x0c,0x04,0x06,0x02,0x03,0x01&#125;;void delay(uint n)&#123; uint i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void stepper()&#123; int i = 0; for (i=7; i&gt;0; i--) // 反转 每次转动45° &#123; P2 = st[i]; delay(100); &#125; &#125;void main()&#123; while(1) &#123; stepper(); &#125;&#125; ​ ‍ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day03","slug":"C52-day03","date":"2023-05-11T01:42:43.000Z","updated":"2023-05-11T01:45:49.992Z","comments":true,"path":"2023/05/11/C52-day03/","link":"","permalink":"http://example.com/2023/05/11/C52-day03/","excerpt":"","text":"虚拟串口代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* time:2023-05-10COM*/# include &quot;reg51.h&quot;unsigned char recdat = 0, flag = 0;void initscon()&#123; SCON = 0X50; // 0101 0000 TMOD = 0X20; // 0010 0000 TH1 = 256 - 3; TL1 = 256 - 3; ES = 1; EA = 1; TR1 = 1;&#125;void scon_isr() interrupt 4 // COM interrupt&#123; recdat = SBUF; RI = 0; flag = 1; &#125;void senddat()&#123; SBUF = recdat; while(!TI); TI = 0;&#125;void main()&#123; initscon(); while(1) &#123; if (flag == 1) &#123; senddat(); flag = 0; &#125; &#125;&#125; ​ LCD1602常用指令码 0X38:设置16 * 2 显示，5*7点阵， 8位数据接口 0X0C：设置开显示，不显示光标 0X06:写一个字符后地址指针加1 0X01: 显示清0，数据指针清0 0X80:LCD第一行的起始地址 0X80+0X40:LCD第二行的起始地址 ‍ LCD1602功能 RS​，片选 RS=0​，输入命令，不显示字符 RS=1​，写入数据，显示字符 RW​，读写操作 RW=0​，写操作 RW=1​，读操作 E​，使能端，高电平有效 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* time:2023-05-10LCD display*/# include &quot;reg51.h&quot;sbit RS = P3^0;sbit RW = P3^1;sbit E = P3^2;unsigned char str[] = &#123;&quot;xuaner&quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;// write signvoid writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; //P3^2 is low ---&gt;E is high P2 = com; delay(5); // delay E = 1; E = 0;&#125;// write Datavoid writedate(unsigned char date)&#123; RS = 1; RW = 0; E = 0; P2 = date; delay(5); E = 1; E = 0;&#125;// initialvoid initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void display()&#123; unsigned int i = 0; writecom(0x80); // second line：0x80 + 0x40 delay(5); /* one Char display writedate(&#x27;x&#x27;); delay(5); writedate(&#x27;u&#x27;); delay(5); writedate(a&#x27;); delay(5); writedate(&#x27;n&#x27;); delay(5); writedate(e&#x27;); delay(5); writedate(&#x27;r&#x27;); delay(5); */ // string display while (str[i] != &#x27;\\0&#x27;) &#123; writedate (str[i]); delay(5); i++; &#125; &#125;void main()&#123; initlcd(); while(1) &#123; display(); &#125;&#125; ​ LCD时钟代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/*time:2023-05-10simple clk*/# include &quot;reg51.h&quot;sbit RS = P3^0;sbit RW = P3^1;sbit E = P3^2;unsigned char count = 0;unsigned int hour = 9, min = 54, sec = 0;unsigned char str[] = &#123;&quot;0123456789&quot;&#125;;unsigned char str1[] = &#123;&quot;xuaner CLK&quot;&#125;;void delay(unsigned char n)&#123; unsigned int i = 0, j = 0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void writecom(unsigned char com)&#123; RS = 0; RW = 0; E = 0; P2 = com; delay(5); E = 1; E = 0;&#125;void writedate(unsigned char date)&#123; RS = 1; RW = 0; E = 0; P2 = date; delay(5); E = 1; E = 0;&#125;void initlcd()&#123; writecom(0x38); writecom(0x0c); writecom(0x06); writecom(0x01);&#125;void display()&#123; unsigned char temp0 = 0, temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0, temp5 = 0; unsigned char i = 0; temp0 = hour / 10; temp1 = hour % 10; temp2 = min / 10; temp3 = min % 10; temp4 = sec / 10; temp5 = sec % 10; writecom(0X80); delay(5); while(str1[i] != &#x27;\\0&#x27;) &#123; writedate(str1[i]); delay(5); i++; &#125; writecom(0X80 + 0X40 + 4); delay(5); writedate(str[temp0]); delay(5); writedate(str[temp1]); delay(5); writedate(&#x27;:&#x27;); delay(5); writedate(str[temp2]); delay(5); writedate(str[temp3]); delay(5); writedate(&#x27;:&#x27;); delay(5); writedate(str[temp4]); delay(5); writedate(str[temp5]); delay(5); &#125;void inittimer()&#123; TMOD = 0x01; TH0 = (65536-50000)/256; // 50ms TL0 = (65536-50000)%256; ET0 = 1; EA = 1; TR0 = 1;&#125;void timer0_isr() interrupt 1&#123; TH0 = (65536-50000)/256; // 50ms TL0 = (65536-50000)%256; count++; if (count == 20) // 1s &#123; sec = sec + 1; count = 0; &#125; if (sec == 60) &#123; min = min + 1; sec = 0; &#125; if (min == 60) &#123; hour = hour + 1; min = 0; &#125; if (hour == 24) &#123; hour = 0; &#125;&#125;void main()&#123; initlcd(); inittimer(); while(1) &#123; display(); &#125;&#125; ​ 点阵显示代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*time:2023-05-10matrix*/# include &quot;reg51.h&quot;unsigned char code tab[] = &#123; 0x00, 0x7e, 0xff, 0xc3, 0xc3, 0xff, 0x7e, 0x00, // 0 0x00, 0x00, 0x43, 0xff, 0xff, 0x03, 0x00, 0x00, // 1 0x00, 0x63, 0xc7, 0xcf, 0xdb, 0xf3, 0x63, 0x00, // 2 0x00, 0x42, 0xdb, 0xdb, 0xdb, 0xff, 0x66, 0x00, // 3 0x00, 0x3e, 0x46, 0xff, 0xff, 0x06, 0x06, 0x00, // 4 &#125;; unsigned char row[] = &#123;0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80&#125;;unsigned char num = 0, flag = 0;sbit key0 = P1^0;void key()&#123; if (flag == 0 &amp;&amp; key0 == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; num++; flag = 0; &#125; if (num == 5) &#123; num = 0; &#125;&#125;void matrix()&#123; unsigned int i = 0; for (i=8*num; i&lt;8*(num+1); i++) &#123; P3 = ~row[i-8*num]; P2 = tab[i]; &#125;&#125;void main()&#123; while(1) &#123; matrix(); key(); &#125;&#125; ​ ‍ DA转换代码​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*time:2023-05-10DA*/# include &quot;reg51.h&quot;unsigned int value = 100, flag = 0;sbit key0 = P1^0;sbit key1 = P1^1;void key()&#123; if (key0 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; value += 10; flag = 0; &#125; if (key1 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key1 == 1) &#123; value -= 10; flag = 0; &#125;&#125;void delay(unsigned int n)&#123; int i=0, j=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;/* pwmvoid PWM()&#123; P2 = 0;delay(100); // duty cycle :change delay P2 = 255; delay(value);&#125;*/void stair()&#123; int i = 0; for (i=0; i&lt;255; i++) &#123; P2 = i; &#125; for (i=255; i&lt;0; i--) &#123; P2 = i; &#125;&#125;void main()&#123; while(1) &#123; // PWM(); stair(); // sawtooth wave key(); &#125;&#125;","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day02","slug":"C52-day02","date":"2023-05-10T00:29:19.000Z","updated":"2023-05-11T01:45:03.314Z","comments":true,"path":"2023/05/10/C52-day02/","link":"","permalink":"http://example.com/2023/05/10/C52-day02/","excerpt":"","text":"矩阵键盘代码​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*time:2023-05-08array buttons */# include &quot;reg51.h&quot;unsigned int num = 9;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F,0X76, 0X79, 0X38, 0X38, 0X3F,0XFF&#125;; // 0-9sbit P10=P1^0;sbit P11=P1^1;sbit P12=P1^2;sbit P13=P1^3;sbit P14=P1^4;sbit P15=P1^5;sbit P16=P1^6;sbit P17=P1^7;void Delay(unsigned int n)&#123; unsigned int i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void key_scan()&#123; P1 = 0xff; /*---------------cycle scan-----------------*/ P1=0xFF; P13=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=1;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=5;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=9;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=13;&#125; P1=0xFF; P12=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=2;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=6;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=10;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=14;&#125; P1=0xFF; P11=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=3;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=7;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=11;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=15;&#125; P1=0xFF; P10=0; if(P17==0)&#123;Delay(20);while(P17==0);Delay(20);num=4;&#125; if(P16==0)&#123;Delay(20);while(P16==0);Delay(20);num=8;&#125; if(P15==0)&#123;Delay(20);while(P15==0);Delay(20);num=12;&#125; if(P14==0)&#123;Delay(20);while(P14==0);Delay(20);num=16;&#125; &#125;void display()&#123; P2 = s[num];&#125;void main()&#123; while(1) &#123; key_scan(); display(); &#125;&#125; ​ 定时器工作方式 interrupt0，13位，当 INT0 引脚由高电平变为低电平时触发中断。 $X&#x3D;8192-N\\frac{12}{fosc}$​ 上次计数为0，要重复计数需要置零 interrupt1，16位，当定时器 0 计数器溢出时触发中断。 $X&#x3D;65536-N\\frac{12}{fosc}$​ 上次计数值为0，要重复计数需要重置初值 interrupt2，8位自动重置定时&#x2F;计数器，当 INT1引脚由高电平变为低电平时触发中断。 interrupt3，8位，只有T0才能使用，当定时器 1 计数器溢出时触发中断。 $X&#x3D;256-N\\frac{12}{fosc}$​ 计数器自动配置初值，不需要用户重置 interrupt4，串口中断，当串口接收完成（RI）或发送完成（TI）时触发中断。 TMOD 寄存器TMOD 的低 4 位控制定时器 0，高 4 位控制定时器 1，每个定时器都有两个工作模式可以选择 M0表示定时器0，M1表示定时器1 TMOD&#x3D;0x20表示定时器1设置为2模式 TMOD&#x3D;0x02表示定时器0设置为2模式 TMOD GATE C&#x2F;T M1 M0 工作模式 0x00 0 0 0 0 模式 0：13 位计数器 0x01 0 0 0 1 模式 1：16 位计数器 0x02 0 0 1 0 模式 2：8 位自动重装载计数器 0x03 0 0 1 1 模式 3：16 位自动重装载计数器 0x04 0 1 0 0 模式 4：外部事件计数 0x05 0 1 0 1 模式 5：保留 0x06 0 1 1 0 模式 6：8 位 PWM 波形发生器 0x07 0 1 1 1 模式 7：16 位 PWM 波形发生器 TH和TL寄存器 TH0/TL0​表示定时器0的高低八位 TH1/TL1​表示定时器1的高低八位 IT寄存器 IT0​，外部中断寄存器 IT1​，外部中断寄存器 IT0/IT1=0​​，低电平触发 IT0/IT1=1​​，下降沿触发 中断寄存器 ET0/ET1​，定时器中断使能寄存器，为1中断允许，为0不允许 EA​，总中断使能寄存器，为1中断允许，为0不允许 TR0/TR1​，定时器启动控制寄存器，为1时开始计数，为0时停止计数。 ‍ 12MHz晶振对应的一个机器周期为1us，需要延时50ms，则从65536-50000开始计数，分为高低八位分别存储计数，当定时器0计数到65536溢出位时，触发timer_isr中断，执行函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*time: 2023-05-08timer*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f&#125;;unsigned char count = 0, num = 0;void inittimer()&#123; TMOD = 0x01; // 0000 0001 TH0 = (65536 - 50000) / 256; // 50ms = 50000us initial value &gt;&gt; 8 TL0 = (65536 - 50000) % 256; ET0 = 1; /* timer0 interrupt on*/ EA = 1; // interrupt on TR0 = 1; //timer0 on&#125;void display()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;/* 0 out interrupt0； 1 timer interrupt0；2 out interrupt1；3 timer interrupt1；4 COM interrupt*/void timer_isr() interrupt 1 &#123; TH0 = (65536 - 50000) / 256; // 50ms = 50000us initial value &gt;&gt; 8 TL0 = (65536 - 50000) % 256; count++; if (count == 20) // setTime 1s &#123; num++; count = 0; &#125;&#125;void main()&#123; inittimer(); while(1) &#123; display(); &#125;&#125; ​ 计数器代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142/*time:2023-05-088bit auto reset count*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f&#125;;unsigned char num = 0;void initcounter()&#123; TMOD = 0X06; // 0000 0110 auto reset TH0 = 255; TL0 = 255; ET0 = 1; EA = 1; TR0 = 1;&#125;void display()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;void counter_isr() interrupt 1&#123; num++;&#125;void main()&#123; initcounter(); while(1) &#123; display(); &#125;&#125; ​ ‍ ‍ ‍","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"C52-day01","slug":"C52-day01","date":"2023-05-08T08:16:11.000Z","updated":"2023-05-08T08:24:21.577Z","comments":true,"path":"2023/05/08/C52-day01/","link":"","permalink":"http://example.com/2023/05/08/C52-day01/","excerpt":"","text":"STC89C52命名规则STC89C52 STC89 C–&gt;工作电压 C：5.5V~3.8V LE:3.6V2.4V&#x2F;3.4V\\2.4V 52表示8K字节程序空间，512字节RAM 最小系统​ LED灯代码​ 1234567891011121314151617181920212223242526272829303132333435/*time: 2023-05-07C Flowing LED*/# include &quot;reg51.h&quot;// define an array of reg P0//unsigned char leds[] = &#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(unsigned int n)&#123; unsigned int i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void led()&#123; int i = 0; for (i=0; i&lt;8; i++) &#123; P2 = ~(0x01&lt;&lt;i); //P2 = ~leds[i]; delay(500); &#125;&#125;void main() &#123; while(1) &#123; led(); &#125;&#125; ​ 数码管数码管16进制显示数码管对应16进制0~F 共阳极数码管 12unsigned char LED7Code[] = &#123;0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e&#125;; 共阴极数码管 12unsigned char LED7Code[] = &#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d, 0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00&#125;; 普通数码管代码​ 12345678910111213141516171819202122232425262728293031323334353637383940/*time: 2023-05-07C LED Display*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F&#125;; // common cathode 0-9/* &#123;0X77, 0X7C, 0X39, 0X5E, 0X79, 0X71, 0X73, 0X3E, 0X31, 0X6E,&#125; &#123;0X38, 0X00&#125;static display 0-9 A-F P U T Y L */void delay(unsigned char n)&#123; unsigned char i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void smg()&#123; int i = 0; for (i=0; i&lt;10; i++) &#123; P2 = s[i]; delay(1000); &#125;&#125;void main()&#123; while(1) &#123; smg(); //P2=0X06; &#125;&#125; ​ 组合74LS13874LS138对数码管进行片选 1234567891011121314151617181920212223242526272829303132333435363738394041/* time:2023-05-07 74LS138 display HELLO*/# include &quot;reg51.h&quot;unsigned char s[] = &#123;0X76, 0X79, 0X38, 0X38, 0X3F&#125;; // common cathode HELLOunsigned char sbi[] = &#123;0X00, 0X01, 0X02, 0X03, 0X04, 0X05, 0X06, 0X07&#125;; //74LS138 chip select/* &#123;0X77, 0X7C, 0X39, 0X5E, 0X79, 0X71, 0X73, 0X3E, 0X31, 0X6E,&#125; &#123;0X38, 0X00&#125;0-9 A-F P U T Y L */void delay(unsigned char n)&#123; unsigned char i, j; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;120; j++); &#125;&#125;void smg()&#123; int i = 0; for (i=0; i&lt;5; i++) &#123; P3 = sbi[i]; P2 = s[i]; delay(10); &#125;&#125;void main()&#123; while(1) &#123; smg(); &#125;&#125; ​ 按钮控制数码管代码​ 123456789101112131415161718192021222324252627282930313233343536373839404142/*time:2023-05-07LED button control*/# include &quot;reg51.h&quot;sbit key0 = P1^0;unsigned char s[] = &#123;0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F&#125;; // 0-9unsigned char num = 0;unsigned char flag = 0;void key()&#123; if (key0 == 0 &amp;&amp; flag == 0) &#123; flag = 1; &#125; if (flag == 1 &amp;&amp; key0 == 1) &#123; num++; flag = 0; &#125;&#125;void seg()&#123; P2 = s[num]; if (num == 10) &#123; num = 0; &#125;&#125;void main()&#123; while(1) &#123; key(); seg(); &#125;&#125; ​","categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"}],"author":"xuaner"},{"title":"前端IC——数电基础","slug":"前端IC——数电基础","date":"2023-01-08T10:58:54.000Z","updated":"2023-01-08T10:59:41.802Z","comments":true,"path":"2023/01/08/前端IC——数电基础/","link":"","permalink":"http://example.com/2023/01/08/%E5%89%8D%E7%AB%AFIC%E2%80%94%E2%80%94%E6%95%B0%E7%94%B5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"信息、编码和逻辑代数信息是用来消除不确定的东西✨ 编码是一种映射或者描述关系。 常见编码：余三码、补码、反码、8421码、格雷码 反码：除符号位外，按位取反 补码：除符号位外，按位取反然后加1 正数的反码和补码都是其本身 逻辑代数计算： (AB)’ = A’ + B’ ​ (A + B)’ = A’B’​ 组合逻辑、时序逻辑电路组合逻辑电路：是任意时刻的输出仅仅取决于当前时刻的输入，与电路之前的历史状态无关（即无记忆能力） 组合逻辑电路的设计通常包含以下几个步骤： 进行逻辑抽象。分析事件的因果关系，确定输入变量和输出变量，列出输入变量和输出变量的逻辑真值表。 写出逻辑函数。将真值表转换为对应的逻辑函数式，或者直接画出卡诺图，然后使用第三章中介绍的卡诺图将逻辑函数进行化简。 根据化简后的逻辑函数，画出逻辑电路图。 时序逻辑电路：输出不仅取决于当前的输入，还取决于电路的历史状态。 因此我们需要一种元件能保存电路的状态信息。如果一个元件带有内部存储功能，它就包含状态，也称之为状态单元（State Element）。 锁存器：锁存器在E的高(低)电平期间对信号敏感触发器：触发器在CP的上升沿(下降沿)对信号敏感二者区别： 具有0 和1两个稳定状态，一旦状态被确定，就能自行保持。一个锁存器或触发器能存储一位二进制码。 锁存器—对脉冲电平敏感的存储电路，在特定输入脉冲电平作用下改变状态。 触发器—对脉冲边沿敏感的存储电路，在时钟脉冲的上升沿或下降沿的变化瞬间改变状态。 ‍ 亚稳态、稳定时间、保持时间建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的最小时间。 保持时间​：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的最小时间。 建立时间裕量：如果数据信号在时钟边沿触发之前的持续时间要大于建立时间Tsu，那么超出的部分时间即为建立时间裕量。 保持时间裕量：如果数据信号在时钟边沿触发之后的保持时间要大于保持时间Thd，那么超出的部分时间即为保持时间裕量。 ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数字IC/数电","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E6%95%B0%E7%94%B5/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数电","permalink":"http://example.com/tags/%E6%95%B0%E7%94%B5/"}],"author":"xuaner"},{"title":"静态时序分析——建立保持时间","slug":"静态时序分析——建立保持时间","date":"2023-01-03T06:05:42.000Z","updated":"2023-01-03T07:01:57.625Z","comments":true,"path":"2023/01/03/静态时序分析——建立保持时间/","link":"","permalink":"http://example.com/2023/01/03/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E4%BF%9D%E6%8C%81%E6%97%B6%E9%97%B4/","excerpt":"","text":"建立时间公式 $$T_{lanuch}+T_{ck2q}+T_{dp}&lt;T_{capture}+T_{cycle}-T_{setup}$$ ​ 如果组合逻辑的延时最大值也满足这个公式，则所有都满足，通常用组合逻辑最大延时检查建立时间 使用组合逻辑最小延时检查保持时间 输入端口到寄存器公式 $$slack&#x3D;T_{capture}+T_{cycle}-T_{setup}-T_{uncertainty}-(T_{lanuch}+T_{ck2q}+T_{dp})&gt;0$$ ​ 输出端口到寄存器公式 $$slack&#x3D;T_{capture}+T_{cycle}-T_{setup}-T_{uncertainty}-T_{output_delay}-(T_{lanuch}+T_{ck2q}+T_{dp})&gt;0$$ ​ 保持时间 捕获路径边沿比发射路径边沿晚一个时钟周期 保持时间和时钟周期无关 保持时间不能计算频率，只能用建立时间去计算 公式 $$T_{lanuch}+T_{ck2q}+T_{dp}&gt;T_{capture}+T_{hold}$$ ​ 建立时间和保持时间的区别 保持时间的检查边沿都是同一个边沿 建立时间的检查边沿捕获的边沿要比发射的边沿晚一个时钟周期 保持时间的检查通常在建立时间检查的前一个上升沿","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"静态时序分析——逻辑综合","slug":"静态时序分析——逻辑综合","date":"2022-12-27T10:33:14.000Z","updated":"2022-12-27T10:34:52.675Z","comments":true,"path":"2022/12/27/静态时序分析——逻辑综合/","link":"","permalink":"http://example.com/2022/12/27/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E7%BB%BC%E5%90%88/","excerpt":"","text":"逻辑综合三个阶段：转译、优化、映射 时序路径约束 输入到寄存器的路径 寄存器到寄存器之间的路径 寄存器到输出的路径 输入直接到输出的路径 12create_clock-period 10 [get_ports Clk]set_dont_touch_network [get_clocks Clk] 对所有定义的时钟网络设置为dont_touch​，即综合的时候不对Clk​信号优化。 如果不加这句，DC会根据CIk的负载自动对他产生Buffer​，而在实际的电路设计中，时钟树（Clock Tree）的综合有自己特别的方法，它需要考虑到实际布线后的物理信息，所以DC不需要在这里对它进行处理，就算处理了也不会符合要求。 12345#定义输入延迟set_input_delay -max 4-clock Clk [get_ports A]#定义输出延迟set_output_delay -max 5.4 -clock Clk [get_ports B] TCL脚本1234567891011sh date //显示开始时间remove_design-designs //移除DC中原有的设计//下面是库的设置，对应图形界面操作的2###########井#############井#set library############井####井##井#####井set search_path [list *********]set target_library &#123;tt.db&#125; set link_library &#123;*tt.db&#125; set symbol_library &#123;tt.sdb&#125; 123456789101112//下面是屏蔽一些warning信息，DC在综合时遇到这些warning时就把它们忽略，//不会报告这些信息，VER-130，VER-129等是不同warning信息的编码，//具体含义可以查看帮助#void warning Info#############suppress_message VER-130suppress_message VER-129suppress_message VER-318suppress_message ELAB-311suppress_message VER-936 123456789//读入example1.v文件，对应于图形界面的3##################################read&amp;amp；link&amp;amp；Check design#read_file -format verilog ~/example1.v#analyze -format verilog ~/example1.v#elaborate EXAMPLE1current_design EXAMPLE1 //把EXAMPLE1指定为当前设计的顶层模块uniquify check design 12345678910//设置一些变量#############################define IO port name#############################set clk[get_ports clk] //设置变量clk的值是[get_ports clk],//在下面的代码中若出现$clk字样，则表示引用该变量的值，即用[get_ports clk]代替$clk。set rst_n [get_ports rst_n]set general_inputs [list a b c]set outputs [get_ports o] 1234567891011/设置约束条件，对应于图形界面的4#set_constraints#############################井//设置时钟约束，对应于图形界面的4.1#1 set constraints for clock signals create_clock -n clock $clk -period 20 -waveform&#123;0 10&#125; //创建一个周期为20ns，占空比为1的时钟set_dont_touch_network[get_clocks clock]set_drive 0 $clk //设置时钟端口的驱动为无穷大set_ideal_network [get_ports clk] //设置时钟端为理想网络 12345//设置复位信号约束，对应于图形界面的4.2#2 set constraints for reset signals set_dont_touch_network $rst_n set_drive 0 $rst_n set_ideal network[get_ports rst_n] 12345678//设置输入延时，对应图形界面的4.3#3 set input delay set_input_delay -clock clock 8$general_inputs/设置输出延时，对应图形界面的4.4#4 set output delay set_output_delay -clock clock 8$outputs 123456//设置面积约束和设计约束，对应图形界面的4.5#5 set design rule constraintsset_max_fanout 4 $general_inputs set_max_transition 0.5 [get_designs &quot;EXAMPLE1&quot;]#6 set area constraint set_max_area 0","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"常见电路","slug":"常见电路","date":"2022-12-22T07:36:15.000Z","updated":"2022-12-22T07:39:58.031Z","comments":true,"path":"2022/12/22/常见电路/","link":"","permalink":"http://example.com/2022/12/22/%E5%B8%B8%E8%A7%81%E7%94%B5%E8%B7%AF/","excerpt":"","text":"4选一​ 123456789101112131415161718192021222324252627282930//两种，一种使用assign赋值语句，用三目运算符嵌套，不便于阅读`timescale 1ns/1nsmodule mux4_1(input [1:0]d1,d2,d3,d0,input [1:0]sel,output [1:0]mux_out);assign mux_out = (sel == 2&#x27;b00) ? d3 : ((sel == 2&#x27;b01) ? d2 : (sel == 2&#x27;b10) ? d1 : d0);endmodule//使用case语句`timescale 1ns/1nsmodule mux4_1(input [1:0]d1,d2,d3,d0,input [1:0]sel,output [1:0]mux_out);reg [1:0] mux_out_reg;always @ (*)begin case(sel) 2&#x27;b00:mux_out_reg = d3; 2&#x27;b01:mux_out_reg = d2; 2&#x27;b10:mux_out_reg = d1; 2&#x27;b11:mux_out_reg = d0; default : mux_out_reg = d0; endcaseendassign mux_out = mux_out_reg;endmodule ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"常见器件","slug":"数字IC/常见器件","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"常见器件","slug":"常见器件","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"}],"author":"xuaner"},{"title":"芯动力——同步时序电路","slug":"芯动力——同步时序电路","date":"2022-12-14T12:41:35.000Z","updated":"2023-01-03T07:08:31.367Z","comments":true,"path":"2022/12/14/芯动力——同步时序电路/","link":"","permalink":"http://example.com/2022/12/14/%E8%8A%AF%E5%8A%A8%E5%8A%9B%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF/","excerpt":"","text":"同步电路设计同步时钟电路的优点： 在同步设计中，EDA工具可以保证电路系统的时序收敛，有效避免了电路设计中竞争冒险现象。 由于触发器只有在时钟边缘才改变取值，很大限度地减少了整个电路受毛刺和噪声影响的可能。 亚稳态 亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。 当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。（电路在翻转的时候） 在这个期间，触发器输出一当中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。 亚稳态不能从根本上消除，但是可以降低影响 $MTBF&#x3D;\\frac{e^{t_{MET}&#x2F;C_2}}{C_1f_{CLK}f_{DATA}}$​ $t_{MEF}$寄存器从时钟上升沿触发后的时序余量时间 指正常没有亚稳态情况下，寄存器输出信号从源寄存器到目的寄存器的建立时间余量。$f_{CLK}$接收时钟域的时钟频率$f_{DATA}$数据的变化频率$C_1$、$C_2$与器件有关的参数 为了避免上节所述的亚稳态问题，就应当使参数MTBF​尽可能的大，通常采用的方法是双锁存器法，即在一个信号进入另一个时钟域之前，将该信号用两个锁存器连续锁存两次，最后得到的采样结果就可以消除亚稳态问题。 ​ 优缺点​ 结构简单、易实现。 增加了两级触发器延时 当快时钟域转到慢时钟域时，易造成慢时钟采样丢失（还未来得及采样，数据就变化了）。故常用于慢时钟域转到快时钟域 两级触发器已经将MTBF变得足够大 三级或者更多级虽然能将亚稳态出现概率降得更低，但是影响电路效率 边沿检测同步器从慢时钟转变为快时钟 适用条件： 输入数据的宽度必须比一个接受时钟周期加上一个同步触发器的old时间要长，最安全的就是两个同步周期宽度。 ​ ‍ 脉冲同步器从快时钟变为慢时钟 ​ 同步器比较 类型 应用 输入 输出 限制 电平检测 同步电平信号时钟域任何时钟域的传输 电平 电平 输入信号必须保持两个接受时钟周期宽度每一次同步之后输入信号必须恢复到无效状态 边沿检测 检测输入信号的上升沿和下降沿适用于低频时钟域向高频时钟域传输 电平或脉冲 脉冲 输入信号必须保持两个接受时钟周期宽度 脉冲检测 同步单周期脉冲信号适用于高频时钟域向低频时钟域传输 脉冲 脉冲 输入的脉冲时间的距离必须保持两个接收时钟周期以上 ‍单bit信号跨时钟域传输 信号从快时钟域到慢时钟域过渡时，慢时钟将可能无法对变化太快的信号实现正确采样 上述同步器法对两个时钟之间的关系要求很严格，而“结绳法”适合任何时钟域的过渡。 将快时钟信号的脉冲周期延长，等到慢时钟同步采样后再“解绳”，还原为原来的脉冲周期宽度。 在慢时钟采样快时钟的时候，结绳法适合采样数据较少即脉冲间隔较大的控制信号。即脉冲间隔Ta&gt;3Tb；即等待3个clkB时钟后，完成复位，才允许下一个输入脉冲。 快时钟到慢时钟结绳就是将单脉冲延长，以方便采集到数据 利用脉冲的边沿做时钟 利用脉冲的电平（部分场合要求最小脉冲宽度）做选择器或者异步复位，置位。 另外的关键点就是什么时候结绳结束（采集到了数据就要让对方回到初始状态） 利用采集到的脉冲做异步复位，置位 利用采集到的脉冲再次结绳采集做握手响应信号 特点 结绳法可以解决快时钟域向慢时钟域过渡的问题，且其适用的范围很广 结绳法实现较为复杂，特别是其效率不高，在对设计性能要求较高的场合应该慎用 数据流数据流大多具有连续性，即背靠背传输；数据流要求信号具有较快的传输速度； 通常使用SRAM​和FIFO​解决传输问题 打两拍将地址总线打两拍●为了避免亚稳态传播不能消除亚稳态现象●因为时钟异步，亚稳态不可避免，但是可以极大降低亚稳态传播的概率低频情况●STA不需要分析这里的异步时序，因为寄存器都可以在一拍内将亚稳态消除，恢复到正常0&#x2F;1态。高频情况●不一定，尤其在28m工艺以下，需要检查两级触发器的延迟保证延迟低，提高系统MTBF​。 ‍ 同步复位异步释放时序电路必须有复位，组合逻辑电路不需要复位 两段式FSM两段式FSM​描述方法其输出一般使用组合逻辑描述，而组合逻辑易产生毛刺等不稳定因素。 如果时序允许插入一个额外的时钟节拍，用于消除毛刺 当不允许使用额外节拍，则改为使用三段式FSM​ 三段式FSM​优势 使FSM​做到了同步寄存器输出 消除了组合逻辑输出的不稳定与毛刺的隐患 更利于时序路径分组 在FPGA/CPLD​等可编程逻辑器件上的综合与布局布线效果更佳 一段式、两段式、三段式分别使用1、2、3个always​块，反之则不成立","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"时序","slug":"时序","permalink":"http://example.com/tags/%E6%97%B6%E5%BA%8F/"}],"author":"xuaner"},{"title":"Markdown语法","slug":"Markdown语法","date":"2022-12-04T12:20:02.000Z","updated":"2023-01-03T07:09:13.887Z","comments":true,"path":"2022/12/04/Markdown语法/","link":"","permalink":"http://example.com/2022/12/04/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"标题123# 一级标题## 二级标题### 三级标题 列表123456+ 无序列表1+ 无序列表2- 无序列表3- 无序列表4* 无序列表5* 无序列表6 121. 有序列表12. 有序列表2 123* [ ] 任务列表1* [ ] 任务列表2* [ ] 任务列表3 块123456‍``` 代码块‍````标记块`&gt; 引述 超链接1![可选](url) 图片超链接 上下标123456789101112直接写在内容中,只取``中间内容hexo中建议使用这种下标:`$a_2$` 上标:`$a^2$`html格式,需要转义下标：a&lt;sub&gt;2&lt;/sub&gt;上标：a&lt;sup&gt;2&lt;/sup&gt;Markdown自带,推荐下标 ：θ~1~ 上标 ：θ^2^ 表格1234567891011| 符号 | 功能 || :----: | :----------------: || * | 零次或多次 || + | 一次或多次 || ？ | 零次或一次 || ^ | 匹配字符串开头 || $ | 匹配字符串结尾 || \\s | 表示空格 || . | 匹配任意一个字符 || \\w | 匹配一个字符 || \\d | 匹配一个数字 | 数学公式123$$中间写公式$$ 四则运算123&#123;&#125; 复合标t_ &#123;a0&#125;\\frac&#123;分子&#125;&#123;分母&#125; 分式表达 Emoji表情123`:中间填入对应的字符:``:sneezing_face:`:sneezing_face: 🤧 或者使用win + .​调出emoji​表情 表情 代码 表情 代码 表情 代码 🤧 :sneezing_face:​ 🤶 :mrs_claus:​ 🍈 :melon:​ 😠 :angry:​ 🤓 :nerd_face:​ 🥝 :kiwi_fruit:​ 👼 :angle:​ 😣 :persevere:​ 🌶 :hot_pepper:​ 😧 :anguished:​ 👿 :imp:​ 🌭 :sneezing_face:​ 😲 :astonished:​ 🎃 :ack_o_lantern:​ 🍔 :hamburger:​ 🤢 :nauseated_face:​ 🍅 :tomato:​ 🍩 :doughnut:​ 🤠 :cowboy_hat_face:​ 🍊 :tangerin:​ 🥕 :carrot:​ 😵 :dizzy_face:​ 🍍 :pineapple:​ 🍌 :banana:​ 😁 :grin:​ 🍑 :peach:​ 🥑 :avocado:​ 😷 :mask:​ 🍋 :lemon:​ 💩 :poop:​ 🐴 :horse:​ 🎠 :carousel_horse:​ 🐼 :panda_face:​ 🐎 :racehorse:​ 🦄 :unicorn:​ 🐵 :sneezing_face:​ 🏇 :horse_racing:​ 🐷 :pig:​ 🐸 :frog:​ 🦊 :fox_face:​ 🐉 :dragon:​ 🤡 :clown_face:​ 🐶 :dog:​ 🐮 :COW:​ 🐔 :chicken:​ ‍","categories":[{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}],"author":"xuaner"},{"title":"芯动力——高质量Verilog设计","slug":"芯动力——高质量Verilog设计","date":"2022-12-03T13:06:07.000Z","updated":"2022-12-22T07:38:36.727Z","comments":true,"path":"2022/12/03/芯动力——高质量Verilog设计/","link":"","permalink":"http://example.com/2022/12/03/%E8%8A%AF%E5%8A%A8%E5%8A%9B%E2%80%94%E2%80%94%E9%AB%98%E8%B4%A8%E9%87%8FVerilog%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"高质量verilog设计可综合语句 always if-else case assign if语句if-else​语句映射为多路选择器 不同的if-else​结构会导致不同的电路结构，根据约束不同，设计：先加法器后选择器；先选择器后加法器 加法器的面积比选择器大，但是先加法器后选择器的延时小。 ​ 单独的if-else​语句没有优先级，会逐一检查，多个if​语句之间具有优先级，多个选择器之间级联，最后一级具有最高优先级。 ​ 若某些设计中，有些信号要求先到达（如关键使能信号、选择信号等），而有些信号需要后到达（如慢速信号、有效时间较长的信号等），此时侧需要使用if…if…结构。设计方法：最高优先级给最迟到达的关键信号 case语句case​和单if​语句类似，但是case​语句互斥 case​的使用注意点： 要在always​块里使用，如果是用always​块描述组合逻辑，注意括号里的敏感变量列表都是电平触发，并且赋值时都要用阻塞赋值“&#x3D;”： always​块里的变量必须声明成reg类型，当然声明成reg​类型不代表一定会综合成寄存器，只是语法要求always​块里要这样； always​：块描述组合逻辑时，用*​可以代表所有always​块内敏感信号； 分支条件要写全，最好补齐default​缺省条件，不然在组合逻辑中可能会由于条件不全导致出现锁存器Latch​； Latch语句综合工具很难解释Latch​ latch​由电平触发，非同步控制。在使能信号有效时latch​相当于通路，在使能信号无效时latch​保持输出状态。DFF​由时钟沿触发同步制。 latch​容易产生毛刺，DFF​则不易产生毛刺。 latch​将静态时序分析变得极为复杂。 Latch​容易在不完备的if-else​和case​中产生 使用完备if-else​语句 使用default​覆盖case​语句 查看综合工具的warning​信息 使用full_case​，告诉综合工具case​已经完备 ​ 使用parallel_case​，告诉综合工具，所有条件互斥且并行，没有优先权 ​ 资源重复利用负载均衡、逻辑复制 资源共享、减小面积 ​ 顺序重排、降低延时 ​ 赋值语句关于assign​： 仅用于信号连接 难以阅读，且多层嵌套后很难被综合器解释 可综合风格always​敏感信号表 所有的组合逻辑或锁存的always​结构必须有敏感信号列表。这个敏感信号列表必须包含所有的输入信号。 综合过程将产生一个取决于除敏感列表中所有其它值的结构，它将可能在行为仿真和门级仿真间产生潜在的失配。 在综合过程中，每个Verilog always​敏感信号列表只能对应一个时钟。 这是将每一个过程限制在单一寄存器类型的要求。 wait​和delay​不能用于可综合RTL​设计 原因：从RTL​级转换到gate​级的综合工具一般都不支持Wait​声明和#delay​声明，为了有效的综合，这些语句应该避免。 例外：在不需要行综合的行为模块中，如测试模块Testbench​、表示行为的虚拟器件模块中可以使用。 非阻塞赋值和阻塞赋值 在时序电路中必须使用非阻塞赋值&lt;=​ 组合逻辑电路必须使用阻塞赋值=​ 异步逻辑和同步逻辑 建议分开异步逻辑与同步逻辑 避免综合时的问题，简化约束和编码难度。 不可应用于非综合模块中（例如：总线模块，总线监视器或是模拟模块）除非他们被设计来综合仿真。 控制逻辑和存储器 建议控制逻辑和存储器逻辑分成独立的模块 便于高层的存储器模块的使用和便于重新描述为不同的存储器类型 优秀的设计 牢记并理解可综合“四大法宝”所对应的硬件结构 写前确认电路指标是什么：性能？面积？ 硬件思维方式，代码不再是一行行的代码而是一块一块的硬件模块 对所需实现的硬件电路“胸有成竹”，有足够的数电基础 降低延时尽可能将延时高的模块放在后面 RTL编码面积减小设计面积： 成本降低、功耗降低 特别是对于FPGA​的设计，直接决着FPGA​的选型 估计设计使用资源的数量，知道设计中哪些部分占用了较大的面积 触发器的数量有功能决定，很难减少，面积则很好估计 组合逻辑—》RTL​代码—》各种操作符 必须使用复杂运算符，需要考虑能否使用资源共享。 多比特操作，应该看一看这个信号的所有比特是否都需要参与操作，如果不是则可以只对需要的部分比特进行操作。 ​ addr&lt;=addr+32;​—》addr[7:5]&lt;=addr[7:5]+1;​ addr[4:0]&lt;=addr[4:0]+0;​ RTL编码功耗$$p_d&#x3D;∑afCV^2$$ pd是电路割点功耗总和，a是该点电路翻转次数，f是电路工作频率，C是该点电容，V表示电压值 RTL​无法改变负载电容、工作电压，只能考虑尽可能降低电路翻转频率 主要措施： 门控时钟 增加使能信号，使得部分电路只有在需要工作时才工作； 对芯片各个模块进行控制，在需要工作时才工作； 除了有用信号和时钟的翻转会消耗功耗组合逻辑产生的毛刺也会大量消耗功耗。但是，毛刺在设计中无法避免，因此，只有尽量减少毛刺在电路中的传播，才可以减少功耗。即，在设计中，尽量把产生毛刺的电路放在传播路径的最后。另外，可以使用一些减少毛刺的技术。 ‍ RTL编码布线 但即使使用最好的布局工具，还是可能出现无法布通的情况。 如果可以在RTL​编码阶段考虑代码可能对布线产生的影响就可能避免最后出现无法布通的情况 RTL设计指导原则指导原则： 面积与速度互换 乒乓操作 流水线设计","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"}],"author":"xuaner"},{"title":"Pandas技巧","slug":"Pandas技巧","date":"2022-12-01T11:21:58.000Z","updated":"2022-12-01T11:39:01.061Z","comments":true,"path":"2022/12/01/Pandas技巧/","link":"","permalink":"http://example.com/2022/12/01/Pandas%E6%8A%80%E5%B7%A7/","excerpt":"","text":"差集12#取df_data1和df_data2的差集，剩下df_data1的余差df_data3=pd.concat([df_data1,df_data2,df_data2]).drop_duplicates(keep=False) 掩膜12345#取a列和b列相等的行df_data2=df_data1[df_data1[&#x27;a&#x27;]==df_data1[&#x27;b&#x27;]]#取a列不为null的行df_data2=df_data1[df_data1[&#x27;a&#x27;].notna()] 替换值12#将a列的元素为 （null） 替换为空df_data1.loc[:,&#x27;a&#x27;]=df_data1.loc[:,&#x27;a&#x27;].replace(&#x27;(null)&#x27;,np.nan)","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pandas","slug":"pandas","permalink":"http://example.com/tags/pandas/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"xuaner"},{"title":"TCL入门","slug":"TCL语法快速上手","date":"2022-11-27T14:35:27.000Z","updated":"2022-12-03T12:04:08.701Z","comments":true,"path":"2022/11/27/TCL语法快速上手/","link":"","permalink":"http://example.com/2022/11/27/TCL%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"变量123456789101112131415161718#置换变量set a &#x27;snow&#x27;puts $a #打印a的值#命令置换#[]内部是一个独立tcl语句set a [expr 3+4]puts $a#结果为7#转义字符puts &#x27;a\\tb&#x27;puts &#x27;a\\nb&#x27;#添加后缀puts $&#123;a&#125;_1#打印7_1 符号123456789#置换set x 1set Y 2puts &quot;\\t[expr $x + $Y]&quot;#打印3,&quot;&quot;中会置换命令和变量puts &#123;\\t[expr $x + $Y]&#125;#打印\\t[expr $x + $Y],&#123;&#125;中的内容当做普通字符 数组1234567891011#定义set cell_1(a_name) &quot;array_1&quot;set cell_1(b_name) &quot;array_2&quot;set cell_1(c_name) &quot;array_3&quot;#取值puts $cell_1(a_name)array size cell_1#打印 3,数组长度为3array names cell_1#打印a_name,b_name,c_name 列表1234567891011121314151617181920212223242526272829303132333435set ive_list&#123;liv1,liv2,liv3&#125;puts $ive_list#合并列表set list1&#123;l1,l2,l3&#125;set list2&#123;s1,s2,s3&#125;concat $list1 $list2#查看长度llength $list1llength [concat $list1 $list1]#返回index的元素,下标从0开始lindex $list1 1#打印l2#得到list1&#123;a,b,c,d,e&#125;的最后一个元素set list1 &#123;a,b,c,d,e&#125;lindex $list1 [expr [llength list1] -1]#末尾追加新元素set list1 &#123;a,b,c&#125;lappend list1 d#排序,默认按照ASICC码排列set list1 &#123;c,d,e,a,b&#125;lsort $list1set list1 &#123;1.0,1.2,0.3,0.1,0&#125;lsort -real $list1#按照浮点数排列set list1 &#123;a,a,e,e,c,c,b,b,d&#125;lsort -unique $list1#排序并唯一化元素 运算表达式1234567#求运算表达式的值expr 1 + 2expr 1 * 2expr 5/2.0#打印浮点数,2.5expr 5/2#打印整数,2 ‍流程控制** 1234567891011121314151617181920212223242526272829303132333435363738#if elseset a 3set b 2if &#123;$a &gt; $b&#125; &#123;puts $a&#125; else &#123;puts $b&#125;#打印2#foreachset list1 &#123;1,2,3&#125;foreach i $list1&#123;puts $i&#125;#打印1,2,3#break,continueset list1 &#123;3,2,1&#125;foreach i $list1&#123;if &#123;$i==2&#125; &#123;break/continue&#125;puts $i&#125;#whileset i 3while &#123;$i&gt;0&#125; &#123;puts $iincr i-1; #等效于 set i [expr $i-1]&#125;#forfor &#123;set i 3&#125; &#123;$i&gt;0&#125; &#123;incr i-1&#125; &#123;puts $i&#125; proc函数1234567891011121314151617#过程函数procproc add &#123;a b&#125; &#123;set sum [expr $a + $b]return $sum&#125;add 3 4#打印7#过程中使用global引用全局变量set a 1proc sample &#123;x&#125; &#123;global aset a [expr $a + 1]return [expr $a + $x]&#125;sample 3#打印5 正则表达式 符号 功能 * 零次或多次 + 一次或多次 ？ 零次或一次 ^ 匹配字符串开头 $ 匹配字符串结尾 \\s 表示空格 . 匹配任意一个字符 \\w 匹配一个字符 \\d 匹配一个数字 文本处理1234567891011121314#open,gets,close#只读模式#第一行开始逐行读取#关闭文件set inputFiles [open file.text r]while &#123;[gets $inputFiles line] &gt;=0&#125; &#123;puts &quot;$line&quot;&#125;close $inputsFiles#写入模式set outputFiles [open file.text w]puts $outputFiles &quot;hello world&quot;close $outputFiles 文本file.txt,读取内容求所有Slack的值之和 Slack &#x3D; -0.0051 Slack &#x3D; -0.0021 Slack &#x3D; -0.0012 12345678910set num 0set $inputFiles [open file.txt r]while &#123;[gets $inputFiles line] &gt;=0&#125; &#123;if &#123;[regexp &#123;^Slack\\s+=\\s+(-?\\d+.?\\d+)&#125;$line total slack]&#125; &#123;set num [expr $sum + $slack]&#125;&#125;close $inputFilesputs $sum ‍Synopsys TCL1234567891011121314151617181920#查看design中的portget_ports portsName#通配符查看get_ports *#查看以C开头的portget_ports C*#查看design中对应的cell的instanceget_cells cellsName#查看design中对应的netget_nets netsName#查看nets的个数llength [get_object_name[get_nets *]]#或者sizeof_collection[get_nets *]#查看pins,以Z开头get_pins */Z","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"TCL","slug":"TCL","permalink":"http://example.com/tags/TCL/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"}],"author":"xuaner"},{"title":"FIFO","slug":"FIFO","date":"2022-11-27T12:39:03.000Z","updated":"2022-12-23T05:58:18.599Z","comments":true,"path":"2022/11/27/FIFO/","link":"","permalink":"http://example.com/2022/11/27/FIFO/","excerpt":"","text":"FIFOFIFO（First In First Out）是一种数据缓冲器 异步FIFO同步FIFO可以看做异步FIFO的一个特例 异步FIFO可以分为 写时钟域地址管理 读时钟域地址管理 读时钟域读地址到写时钟域的格雷码同步 写时钟域写地址到读时钟域的格雷码同步 写时钟域的满和将满信号的产生 读时钟域的空和将空信号的产生 格雷码 避免采样时钟问题 引入格雷码，格雷码相邻地址只有1bit​跳变 格雷码的原理:从右往左，每2位异或 0000​-&gt;0000​ 0010​​-&gt;0011​​ 123456789101112131415161718192021222324//以FIFO深度16,格雷码编解码情况核心代码//编码always@(posedge clka or posedge reset) if(reset) b&lt;=4&#x27;b00; else b&lt;=a^(a&gt;&gt;1);//异步采样always@(posedge clka or posedge reset) if(reset) c&lt;=4&#x27;b00; else c&lt;=b;//解码always@(posedge clka or posedge reset) if(reset) d&lt;=4&#x27;b00; else begin d[3]=c[3]; d[2]=c[3]^c[2]; d[1]=c[2]^c[1]; d[0]=c[1]^c[0]; end 注意，先将clka​时钟的地址Gray​编码，然后用b​时钟采样Gray​编码地址并暂存，最后用b​时钟对暂存的Gray​编码地址进行译码。 省略b​时钟采样暂存的Gray​编&#x2F;解码是没有任何意义的。 格雷码的问题并不是一定要用格雷码做读写指针，而是当深度为2次幂的时候列好格雷码满足消除亚稳态的需求在非2次幂深度情况下，格雷码已经不再适用，此时的解决方法通常有 若深度为偶数，可采用最接近的2次幂的格雷码编码，在此基础上修改； 深度为一般数值时，可自行设计一种逻辑电路，或者查找表，以实现指针每次只跳变一次的功能； 以上方法通常在设计层面较为复杂，若无特定需求，可将FIFO深度设置为2次幂，浪费一些存储空间，来化简控制电路的复杂度。 FIFO深度吞吐量相同满足 (A&#x2F;B) * f1&#x3D;(Y&#x2F;X) * f2 深度计算公式 fifo_depth&#x3D;data_length-(data_length&#x2F;f1) * [(Y&#x2F;X) * f2] ‍","categories":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"}],"tags":[{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"FIFO","slug":"FIFO","permalink":"http://example.com/tags/FIFO/"}],"author":"xuaner"},{"title":"测试博客","slug":"测试","date":"2022-11-26T12:41:21.000Z","updated":"2022-11-26T12:45:18.908Z","comments":true,"path":"2022/11/26/测试/","link":"","permalink":"http://example.com/2022/11/26/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"第一篇测试博客","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试区","slug":"测试区","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95%E5%8C%BA/"}],"author":"xuaner"}],"categories":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数字IC/数电","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E6%95%B0%E7%94%B5/"},{"name":"静态时序分析","slug":"数字IC/静态时序分析","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"},{"name":"常见器件","slug":"数字IC/常见器件","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%97IC/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"},{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://example.com/tags/STM32/"},{"name":"51单片机","slug":"51单片机","permalink":"http://example.com/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"数字IC","slug":"数字IC","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97IC/"},{"name":"数电","slug":"数电","permalink":"http://example.com/tags/%E6%95%B0%E7%94%B5/"},{"name":"静态时序分析","slug":"静态时序分析","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"},{"name":"Verilog","slug":"Verilog","permalink":"http://example.com/tags/Verilog/"},{"name":"常见器件","slug":"常见器件","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E5%99%A8%E4%BB%B6/"},{"name":"时序","slug":"时序","permalink":"http://example.com/tags/%E6%97%B6%E5%BA%8F/"},{"name":"实用工具","slug":"实用工具","permalink":"http://example.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"pandas","slug":"pandas","permalink":"http://example.com/tags/pandas/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"TCL","slug":"TCL","permalink":"http://example.com/tags/TCL/"},{"name":"FIFO","slug":"FIFO","permalink":"http://example.com/tags/FIFO/"},{"name":"测试区","slug":"测试区","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95%E5%8C%BA/"}]}